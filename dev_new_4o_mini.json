[
    {
        "question_id": 0,
        "db_id": "california_schools",
        "question": "Consider the average difference between K-12 enrollment and 15-17 enrollment of schools that are locally funded, list the names and DOC type of schools which has a difference above this average.",
        "evidence": "Difference between K-12 enrollment and 15-17 enrollment can be computed by `Enrollment (K-12)` - `Enrollment (Ages 5-17)`",
        "SQL": "SELECT T2.School, T2.DOCType FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.FundingType = 'Locally funded' AND (T1.`Enrollment (K-12)` - T1.`Enrollment (Ages 5-17)`) > (SELECT AVG(T3.`Enrollment (K-12)` - T3.`Enrollment (Ages 5-17)`) FROM frpm AS T3 INNER JOIN schools AS T4 ON T3.CDSCode = T4.CDSCode WHERE T4.FundingType = 'Locally funded')",
        "difficulty": "challenging",
        "answer": "SELECT `School`, `DOCType` FROM schools WHERE `FundingType` = 'Locally funded' AND (`Enrollment (K-12)` - `Enrollment (Ages 5-17)`) > (SELECT AVG(`Enrollment (K-12)` - `Enrollment (Ages 5-17)`) FROM frpm)",
        "error reason": "4o mini used column Enrollment (K-12) that does not exist in schools. Misaligned correspondence between tables and columns.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 1,
        "db_id": "california_schools",
        "question": "Under whose administration does the school with the highest number of test takers whose total SAT Scores are greater or equal to 1500 belong to? Indicate his or her full name.",
        "evidence": "full name means first name, last name; There are at most 3 administrators for each school; SAT Scores are greater or equal to 1500 refers to NumGE1500",
        "SQL": "SELECT T2.AdmFName1 || ' ' || T2.AdmLName1, T2.AdmFName2 || ' ' || T2.AdmLName2, T2.AdmFName3 || ' ' || T2.AdmLName3 FROM satscores AS T1 INNER JOIN schools AS T2 ON T1.cds = T2.CDSCode ORDER BY T1.NumGE1500 DESC LIMIT 1",
        "difficulty": "challenging",
        "answer": "SELECT AdmFName1 || ' ' || AdmLName1 AS FullName FROM schools JOIN satscores ON schools.CDSCode = satscores.cds ORDER BY satscores.NumGE1500 DESC LIMIT 1",
        "error reason": "4o mini did not notice that AdmLName2, AdmFName2, AdmLName3, AdmFName3 are equally important columns as AdmLName1, AdmFName1.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 2,
        "db_id": "california_schools",
        "question": "Of the schools that offers a magnet program serving a grade span of Kindergarten to 8th grade, how many offers Multiple Provision Types? List the cities that offers a Kindergarten to 8th grade span and indicate how many schools are there serving such grade span for each city.",
        "evidence": "Kindergarten to 8th grade refers to K-8; 'Offers a magnet program' means Magnet = 1.",
        "SQL": "SELECT T2.City, COUNT(T2.CDSCode) FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.Magnet = 1 AND T2.GSoffered = 'K-8' AND T1.`NSLP Provision Status` = 'Multiple Provision Types' GROUP BY T2.City",
        "difficulty": "challenging",
        "answer": "SELECT `City`, COUNT(*) AS `School Count` FROM schools WHERE `Magnet` = 1 AND `GSserved` BETWEEN 'K' AND '8' GROUP BY `City` HAVING COUNT(DISTINCT `FundingType`) > 1",
        "error reason": "The misinterpretation of Multiple Provision Types as HAVING COUNT(DISTINCT `FundingType`) > 1 and serving a grade span of Kindergarten to 8th grade as `GSserved` BETWEEN 'K' AND '8', indicating a failure to recall the column description.",
        "error type": [
            1,
            2
        ]
    },
    {
        "question_id": 3,
        "db_id": "california_schools",
        "question": "What is the e-mail address of the administrators of the school located in the San Bernardino county, District of San Bernardino City Unified that opened between 1/1/2009 to 12/31/2010 whose school types are public Intermediate/Middle Schools and Unified Scools?",
        "evidence": "Intermediate/Middle Schools refers to SOC = 62; Unified School refers to DOC = 54; years between 2009 and 2010 can refer to 'between 1/1/2009 to 12/31/2010'",
        "SQL": "SELECT T2.AdmEmail1,T2.AdmEmail2,T2.AdmEmail3 FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.County = 'San Bernardino' AND T2.City = 'San Bernardino' AND T2.DOC = 54 AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31' AND T2.SOC = 62",
        "difficulty": "challenging",
        "answer": "SELECT AdmEmail1, AdmEmail2, AdmEmail3 FROM schools WHERE County = 'San Bernardino' AND District = 'San Bernardino City Unified' AND OpenDate BETWEEN '2009-01-01' AND '2010-12-31' AND (School Type = 'Intermediate/Middle Schools (Public)' OR School Type = 'Unified School District')",
        "error reason": "Failed to understand that Intermediate/Middle Schools refers to SOC = 62; Unified School refers to DOC = 54; and also produce syntax error, with no `` restricting 'school type'.",
        "error type": [
            1,
            3
        ]
    },
    {
        "question_id": 4,
        "db_id": "financial",
        "question": "For the branch which located in the south Bohemia with biggest number of inhabitants, what is the percentage of the male clients?",
        "evidence": "Percentage of the male clients = DIVIDE(COUNT(male clients), COUNT(clients)) * 100%; Male refers to gender = 'M', A3 is the region name. A4 contains the information about inhabitants.",
        "SQL": "SELECT (SUM(CASE WHEN gender = 'M' THEN 1 ELSE 0 END) * 100.0) / COUNT(*) AS male_percentage FROM client WHERE district_id = (SELECT district_id FROM district WHERE A3 = 'south Bohemia' ORDER BY CAST(A4 AS INTEGER) DESC LIMIT 1)",
        "difficulty": "challenging",
        "answer": "WITH DistrictInfo AS (     SELECT `district_id`     FROM district     WHERE A3 = 'south Bohemia'     ORDER BY A4 DESC     LIMIT 1 ), ClientCounts AS (     SELECT          COUNT(*) AS total_clients,         SUM(CASE WHEN gender = 'M' THEN 1 ELSE 0 END) AS male_clients     FROM client     WHERE `district_id` IN (SELECT `district_id` FROM DistrictInfo) ) SELECT      (male_clients * 100.0 / total_clients) AS male_percentage FROM ClientCounts",
        "error reason": "The text and integer conversions in field \u201cA4\u201d failed, causing 95907 to be considered greater than 102609 in this case, and therefore in the wrong order.",
        "error type": [
            4
        ]
    },
    {
        "question_id": 5,
        "db_id": "financial",
        "question": "For the clients who first applied the loan in 1993/7/5, what is the increase rate of their total account balance from 1993/3/22 to 1998/12/27 in percent?",
        "evidence": "Increase rate of his/her account balance = [(balance of date A - balance of date B) / balance of Date B] * 100%",
        "SQL": "SELECT CAST((SUM(IIF(T3.date = '1998-12-27', T3.balance, 0)) - SUM(IIF(T3.date = '1993-03-22', T3.balance, 0))) AS REAL) * 100 / SUM(IIF(T3.date = '1993-03-22', T3.balance, 0)) FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN trans AS T3 ON T3.account_id = T2.account_id WHERE T1.date = '1993-07-05'",
        "difficulty": "challenging",
        "answer": "SELECT (SUM(case when t.date = '1998-12-27' then t.balance else 0 end) - SUM(case when t.date = '1993-03-22' then t.balance else 0 end)) * 100.0 / SUM(case when t.date = '1993-03-22' then t.balance else 0 end) AS increase_rate FROM loan l JOIN account a ON l.account_id = a.account_id JOIN trans t ON a.account_id = t.account_id WHERE l.date = '1993-07-05' AND t.date IN ('1993-03-22', '1998-12-27')",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 6,
        "db_id": "financial",
        "question": "For loans contracts which are still running where client are in debt, list the district of them and the state the percentage unemployment rate increment from year 1995 to 1996.",
        "evidence": "Unemployment increment rate in percentage = [(unemployment rate 2016 - unemployment rate 2015) / unemployment rate 2015] * 100%; unemployment rate 2015 appears in the A12; unemployment rate 2016 appears in the A13; Loan contracts which are still running where client are in debt can be presented as status = 'D'",
        "SQL": "SELECT T3.A2, CAST((T3.A13 - T3.A12) AS REAL) * 100 / T3.A12 FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id INNER JOIN district AS T3 ON T2.district_id = T3.district_id WHERE T1.status = 'D'",
        "difficulty": "challenging",
        "answer": "SELECT d.`district_id`, (d.`A13` - d.`A12`) AS `unemployment_increment` FROM loan l JOIN disp di ON l.`account_id` = di.`account_id` JOIN district d ON di.`district_id` = d.`district_id` WHERE l.`status` = 'D'",
        "error reason": "Used a district_id column that didn't exist in disp. Misaligned table and column correspondences, failed to recall.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 7,
        "db_id": "financial",
        "question": "Please list the account types that are not eligible for loans, and the average income of residents in the district where the account is located exceeds $8000 but is no more than $9000.",
        "evidence": "A11 represents the average salary; Salary and income share the similar meanings; when the account type = 'OWNER', it's eligible for loans",
        "SQL": "SELECT DISTINCT T3.type FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id INNER JOIN disp AS T3 ON T2.account_id = T3.account_id WHERE T3.type != 'OWNER' AND T1.A11 BETWEEN 8000 AND 9000",
        "difficulty": "challenging",
        "answer": "SELECT DISTINCT `disp`.`type` FROM `account` INNER JOIN `disp` ON `account`.`account_id` = `disp`.`account_id` INNER JOIN `district` ON `account`.`district_id` = `district`.`district_id` WHERE `disp`.`type` = 'DISPONENT' AND `district`.`A11` > 8000 AND `district`.`A11` <= 9000",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 8,
        "db_id": "toxicology",
        "question": "What elements are in the TR004_8_9 bond atoms?",
        "evidence": "TR004_8_9 bond atoms refers to bond_id = 'TR004_8_9'; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "SQL": "SELECT DISTINCT T1.element FROM atom AS T1 INNER JOIN connected AS T2 ON T1.atom_id = T2.atom_id WHERE T2.bond_id = 'TR004_8_9'",
        "difficulty": "challenging",
        "answer": "SELECT DISTINCT a.`element` FROM connected c JOIN atom a ON c.`atom_id` = a.`atom_id` OR c.`atom_id2` = a.`atom_id` WHERE c.`bond_id` = 'TR004_8_9'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 9,
        "db_id": "toxicology",
        "question": "What elements are in a double type bond?",
        "evidence": "double type bond refers to bond_type = ' = '; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "SQL": "SELECT DISTINCT a.element FROM atom a JOIN connected c ON a.atom_id = c.atom_id OR a.atom_id = c.atom_id2 JOIN bond b ON c.bond_id = b.bond_id WHERE b.bond_type = '='",
        "difficulty": "challenging",
        "answer": "SELECT DISTINCT a.element FROM bond b JOIN connected c ON b.bond_id = c.bond_id JOIN atom a ON c.atom_id = a.atom_id OR c.atom_id2 = a.atom_id WHERE b.bond_type = '='",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 10,
        "db_id": "toxicology",
        "question": "Which element is the least numerous in non-carcinogenic molecules?",
        "evidence": "label = '-' means molecules are non-carcinogenic; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "SQL": "SELECT T.element FROM ( SELECT T1.element, COUNT(DISTINCT T1.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '-' GROUP BY T1.element ORDER BY COUNT(DISTINCT T1.molecule_id) ASC LIMIT 4 ) t",
        "difficulty": "challenging",
        "answer": "SELECT element FROM atom WHERE molecule_id IN (SELECT molecule_id FROM molecule WHERE label = '-') GROUP BY element ORDER BY COUNT(*) ASC LIMIT 1",
        "error reason": "Failed to consider tie for first place sitution.",
        "error type": [
            6
        ]
    },
    {
        "question_id": 11,
        "db_id": "toxicology",
        "question": "How many atoms with iodine and sulfur type elements are there in single bond molecules?",
        "evidence": "with iodine element refer to element = 'i'; with sulfur element refers to element = 's'; single type bond refers to bond_type = '-';",
        "SQL": "SELECT COUNT(*) FROM atom WHERE element IN ('s', 'i') AND molecule_id IN (SELECT molecule_id FROM bond GROUP BY molecule_id HAVING SUM(CASE WHEN bond_type IS NULL OR bond_type <> '-' THEN 1 ELSE 0 END) = 0)",
        "difficulty": "challenging",
        "answer": "SELECT COUNT(DISTINCT a.`atom_id`) FROM atom a JOIN bond b ON a.`molecule_id` = b.`molecule_id` WHERE (a.`element` = 'i' OR a.`element` = 's') AND b.`bond_type` = '-'",
        "error reason": "Mistaken single bond molecule for molecule that has single bonds instead of molecule that is only consisting of single bonds.",
        "error type": [
            1
        ]
    },
    {
        "question_id": 12,
        "db_id": "toxicology",
        "question": "What percentage of carcinogenic-type molecules does not contain fluorine?",
        "evidence": "label = '+' mean molecules are carcinogenic; contain fluorine refers to element = 'f'; percentage = DIVIDE(SUM(element = 'f'), COUNT(molecule_id)) as percent where label = '+'",
        "SQL": "SELECT CAST( COUNT(DISTINCT T2.molecule_id) - COUNT(DISTINCT CASE WHEN T1.element = 'f' THEN T2.molecule_id ELSE NULL END) AS REAL) * 100 / COUNT(DISTINCT T2.molecule_id) FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.label = '+'",
        "difficulty": "challenging",
        "answer": "SELECT (COUNT(DISTINCT m.`molecule_id`) - (SELECT COUNT(DISTINCT m1.`molecule_id`) FROM molecule m1 JOIN atom a ON m1.`molecule_id` = a.`molecule_id` WHERE m1.`label` = '+' AND a.`element` = 'f')) * 100.0 / COUNT(DISTINCT m.`molecule_id`) AS percentage FROM molecule m WHERE m.`label` = '+'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 13,
        "db_id": "toxicology",
        "question": "Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.",
        "evidence": "TR000 is the molecule id; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "SQL": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3",
        "difficulty": "challenging",
        "answer": "SELECT DISTINCT element FROM atom WHERE molecule_id = 'TR000' ORDER BY element LIMIT 3",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 14,
        "db_id": "toxicology",
        "question": "List all the elements of atoms that can not bond with any other atoms.",
        "evidence": "element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium; atoms cannot bond with other atoms means atom_id NOT in connected table;",
        "SQL": "SELECT DISTINCT element FROM atom WHERE atom_id NOT IN (SELECT atom_id FROM connected UNION SELECT atom_id2 FROM connected)",
        "difficulty": "challenging",
        "answer": "SELECT DISTINCT a.element FROM atom a LEFT JOIN connected c ON a.atom_id = c.atom_id WHERE c.atom_id IS NULL",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 15,
        "db_id": "toxicology",
        "question": "Which bond type accounted for the majority of the bonds found in molecule TR018 and state whether or not this molecule is carcinogenic if possible?",
        "evidence": "TR018 is the molecule id; majority of the bond found refers to MAX(COUNT(bond_type)); label = '+' mean molecules are carcinogenic; label = '-' means molecules are non-carcinogenic",
        "SQL": "SELECT T.bond_type FROM ( SELECT T1.bond_type, COUNT(T1.molecule_id) FROM bond AS T1  WHERE T1.molecule_id = 'TR018' GROUP BY T1.bond_type ORDER BY COUNT(T1.molecule_id) DESC LIMIT 1 ) AS T",
        "difficulty": "challenging",
        "answer": "SELECT b.bond_type, m.label FROM bond AS b JOIN molecule AS m ON b.molecule_id = m.molecule_id WHERE b.molecule_id = 'TR018' GROUP BY b.bond_type ORDER BY COUNT(b.bond_type) DESC LIMIT 1",
        "error reason": "Unnecessary table joins were performed resulting in data loss.",
        "error type": [
            5
        ]
    },
    {
        "question_id": 16,
        "db_id": "toxicology",
        "question": "List all the different elements of the toxicology of the molecule \"TR004\".",
        "evidence": "TR004 is the molecule id; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "SQL": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR004'",
        "difficulty": "challenging",
        "answer": "SELECT DISTINCT element FROM atom WHERE molecule_id = 'TR004'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 17,
        "db_id": "toxicology",
        "question": "What are the elements of the atoms of TR144_8_19?",
        "evidence": "TR144_8_19 is the bond id; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "SQL": "SELECT T2.element FROM connected AS T1 INNER JOIN atom AS T2 ON T1.atom_id = T2.atom_id WHERE T1.bond_id = 'TR144_8_19'",
        "difficulty": "challenging",
        "answer": "SELECT DISTINCT a.`element` FROM connected c JOIN atom a ON c.`atom_id` = a.`atom_id` OR c.`atom_id2` = a.`atom_id` WHERE c.`bond_id` = 'TR144_8_19'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 18,
        "db_id": "toxicology",
        "question": "What is the composition of element chlorine in percentage among the molecules with single bond?",
        "evidence": "element chlorine refers to element = 'cl'; single bond refers to bond_type = '-'; percentage = DIVIDE(SUM(element = 'cl'), COUNT(atom_id)) as percent where bond_type = '-'",
        "SQL": "SELECT (SUM(CASE WHEN element = 'cl' THEN 1 ELSE 0 END) * 100.0) / COUNT(*) AS chlorine_percentage FROM atom WHERE molecule_id IN (SELECT DISTINCT molecule_id FROM bond WHERE bond_type = '-')",
        "difficulty": "challenging",
        "answer": "WITH SingleBondMolecules AS (SELECT DISTINCT b.molecule_id FROM bond b WHERE b.bond_type = '-') SELECT (COUNT(CASE WHEN a.element = 'cl' THEN 1 END) * 100.0 / COUNT(*)) AS cl_percentage FROM atom a JOIN SingleBondMolecules s ON a.molecule_id = s.molecule_id",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 19,
        "db_id": "card_games",
        "question": "What is the percentage of cards whose language is French among the Story Spotlight cards?",
        "evidence": "Story Spotlight card refers to isStorySpotlight = 1; French is the language; Percentage = Divide(Count(id) where language = 'French' and isStorySpotlight = 1, Count(id) where isStorySpotlight = 1)*100",
        "SQL": "SELECT 100.0 * (SELECT COUNT(DISTINCT c.uuid) FROM cards c JOIN foreign_data fd ON c.uuid = fd.uuid WHERE c.isStorySpotlight = 1 AND fd.language = 'French') / (SELECT COUNT(DISTINCT uuid) FROM cards WHERE isStorySpotlight = 1) AS percentage",
        "difficulty": "challenging",
        "answer": "SELECT (SELECT COUNT(*) FROM cards WHERE isStorySpotlight = 1 AND uuid IN (SELECT uuid FROM foreign_data WHERE language = 'French')) * 100.0 / (SELECT COUNT(*) FROM cards WHERE isStorySpotlight = 1) AS percentage_of_french_cards",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 20,
        "db_id": "card_games",
        "question": "What percentage of cards with format commander and legal status do not have a content warning?",
        "evidence": "do not have a content warning refers to hasContentWarning = 0; \npercentage refers to DIVIDE(COUNT(hasContentWarning = 0),COUNT(ID))*100 where \nformat = 'commander' AND Status = 'legal';\n",
        "SQL": "SELECT CAST(SUM(CASE WHEN T1.hasContentWarning = 0 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.format = 'commander' AND T2.status = 'Legal'",
        "difficulty": "challenging",
        "answer": "SELECT (COUNT(CASE WHEN c.hasContentWarning = 0 THEN 1 END) * 100.0 / COUNT(*)) AS Percentage FROM cards AS c JOIN legalities AS l ON c.uuid = l.uuid WHERE l.format = 'commander' AND l.status = 'Legal'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 21,
        "db_id": "card_games",
        "question": "Which of these artists have designed a card in the set Coldsnap, Jeremy Jarvis, Aaron Miller or Chippy?",
        "evidence": "card set Coldsnap refers to name = 'Coldsnap'; Jeremy Jarvis, Aaron Miller or Chippy are the name of artists which refers to artist IN ('Jeremy Jarvis', 'Aaron Miller','Chippy');",
        "SQL": "SELECT T1.artist FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE (T2.name = 'Coldsnap' AND T1.artist = 'Chippy') OR (T2.name = 'Coldsnap' AND T1.artist = 'Aaron Miller') OR (T2.name = 'Coldsnap' AND T1.artist = 'Jeremy Jarvis') GROUP BY T1.artist",
        "difficulty": "challenging",
        "answer": "SELECT DISTINCT artist FROM cards c JOIN sets s ON c.setCode = s.code WHERE s.name = 'Coldsnap' AND c.artist IN ('Jeremy Jarvis', 'Aaron Miller', 'Chippy')",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 22,
        "db_id": "card_games",
        "question": "What is the percentage of incredibly powerful cards in the set Coldsnap?",
        "evidence": "card set Coldsnap refers to name = 'Coldsnap'; foil is incredibly powerful refers to cardKingdomFoilId = cardKingdomId AND cardKingdomId is not null; the percentage of incredibly powerful cards in the set refers to DIVIDE(SUM(incredibly powerful), SUM(name = 'Coldsnap'))*100\n\n",
        "SQL": "SELECT CAST(SUM(CASE WHEN T1.cardKingdomFoilId IS NOT NULL AND T1.cardKingdomId IS NOT NULL THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.id) FROM cards AS T1 INNER JOIN sets AS T2 ON T2.code = T1.setCode WHERE T2.name = 'Coldsnap'",
        "difficulty": "challenging",
        "answer": "SELECT (COUNT(CASE WHEN cardKingdomFoilId IS NOT NULL THEN 1 END) * 100.0) / COUNT(*) AS percentage FROM cards INNER JOIN sets ON cards.setCode = sets.code WHERE sets.name = 'Coldsnap'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 23,
        "db_id": "card_games",
        "question": "For all the set of cards that has Brazil Portuguese translation, what is the percentage of them are only available online?",
        "evidence": "Brazil Portuguese translation refers to language = 'Portuguese (Brazil)'; only available online refers to isOnlineOnly = 1; percentage of online only Brazil Portuguese in all Brazil Portuguese cards refers to DIVIDE(SUM(isOnlineOnly = 1), SUM(language = 'Portuguese (Brazil)))*100",
        "SQL": "SELECT CAST(SUM(CASE WHEN isOnlineOnly = 1 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(id) FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE language = 'Portuguese (Brazil)' )",
        "difficulty": "challenging",
        "answer": "SELECT (COUNT(CASE WHEN s.isOnlineOnly = 1 THEN 1 END) * 100.0 / COUNT(*)) AS percentage_online FROM sets s JOIN set_translations st ON s.code = st.setCode WHERE st.language = 'Portuguese (Brazil)'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 24,
        "db_id": "card_games",
        "question": "Among the cards whose version of frame style is 1997, what is the status of the card illustrated by D. Alexander Gregory in legacy play format that has sensitive content or Wizards of the Coast?",
        "evidence": "version of frame style is 1997 refers to frameVersion = '1997'; illustrated by D. Alexander Gregory refers to artist = 'D. Alexander Gregory'; sensitive content refers to hasContentWarning = 1; legacy play format refers to format = 'legacy'; status of the card refers to status",
        "SQL": "SELECT DISTINCT T2.status FROM cards AS T1 INNER JOIN legalities AS T2 ON T2.uuid = T1.uuid WHERE T1.frameVersion = 1997 AND T1.hasContentWarning = 1 AND T1.artist = 'D. Alexander Gregory' AND T2.format = 'legacy'",
        "difficulty": "challenging",
        "answer": "SELECT l.status FROM cards AS c JOIN legalities AS l ON c.uuid = l.uuid WHERE c.artist = 'D. Alexander Gregory' AND c.frameVersion = '1997' AND l.format = 'legacy' AND c.hasContentWarning = 1",
        "error reason": "No disinct added.",
        "error type": [
            5
        ]
    },
    {
        "question_id": 25,
        "db_id": "card_games",
        "question": "List the names of all the cards in the set Hour of Devastation and find the formats in which these cards are legal.",
        "evidence": "the set Hour of Devastation refers to set.name = 'Hour of Devastation'; names of all the cards in the set refers to cards.name; legal cards refers to status = 'legal'; the formats refers to format",
        "SQL": "SELECT DISTINCT T2.name , CASE WHEN T1.status = 'Legal' THEN T1.format ELSE NULL END FROM legalities AS T1 INNER JOIN cards AS T2 ON T2.uuid = T1.uuid WHERE T2.setCode IN ( SELECT code FROM sets WHERE name = 'Hour of Devastation' )",
        "Alternative SQL": "SELECT c.name, GROUP_CONCAT(l.format, ', ') AS legal_formats FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE c.setCode = (SELECT code FROM sets WHERE name = 'Hour of Devastation') AND l.status = 'Legal' GROUP BY c.name",
        "difficulty": "challenging",
        "answer": "SELECT c.name, l.format FROM cards c JOIN sets s ON c.setCode = s.code JOIN legalities l ON c.uuid = l.uuid WHERE s.name = 'Hour of Devastation'",
        "error reason": "No disinct added. Semantic misunderstanding. Failed to understand that legal cards refers to status = 'legal'.",
        "error type": [
            1,
            5
        ]
    },
    {
        "question_id": 26,
        "db_id": "codebase_community",
        "question": "Which user added a bounty amount of 50 to the post title mentioning variance?",
        "evidence": "\"bounty amount of 50 refers to BountyAmount = 50; user refers to DisplayName",
        "SQL": "SELECT T3.DisplayName FROM posts AS T1 INNER JOIN votes AS T2 ON T1.Id = T2.PostId INNER JOIN users AS T3 ON T3.Id = T2.UserId WHERE T2.BountyAmount = 50 AND T1.Title LIKE '%variance%'",
        "difficulty": "challenging",
        "answer": "SELECT v.UserId FROM votes v JOIN posts p ON v.PostId = p.Id WHERE v.BountyAmount = 50 AND p.Title LIKE '%variance%'",
        "error reason": "Mistaken the user query 'Which user' to 'Which userid'. Semantic misunderstanding.",
        "error type": [
            1
        ]
    },
    {
        "question_id": 27,
        "db_id": "codebase_community",
        "question": "What is the percentage difference of student badges given during 2010 and 2011?",
        "evidence": "We need to query the `badges` table to find the number of `Student` badges given during 2010 and 2011. The relevant columns are `Name` for the badge name and `Date` for when the badge was obtained. We'll extract the year from `Date` using `strftime('%Y', Date)`, filter for the years 2010 and 2011, and count the number of badges for each year. Then, we'll calculate the percentage difference between the counts of these two years.",
        "SQL": "SELECT  ((count_2011 - count_2010) * 100.0 / count_2010) AS percentage_difference FROM ( SELECT SUM(CASE WHEN strftime('%Y', `Date`) = '2010' THEN 1 ELSE 0 END) AS count_2010, SUM(CASE WHEN strftime('%Y', `Date`) = '2011' THEN 1 ELSE 0 END) AS count_2011 FROM `badges` WHERE `Name` = 'Student') AS counts",
        "difficulty": "challenging",
        "answer": "SELECT ((SELECT COUNT(*) FROM badges WHERE strftime('%Y', `Date`) = '2011') - (SELECT COUNT(*) FROM badges WHERE strftime('%Y', `Date`) = '2010')) * 100.0 / (SELECT COUNT(*) FROM badges WHERE strftime('%Y', `Date`) = '2010') AS percentage_difference",
        "error reason": "Missing the filter name='student', indicating that the LLM has forgot user requirement. Memory recall failure.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 28,
        "db_id": "codebase_community",
        "question": "Among posts by Harvey Motulsky and Noah Snyder, which one has higher popularity?",
        "evidence": "Higher view count means the post has higher popularity; MAX(SUM(ViewCount)) where DisplayName = 'Harvey Motulsky' OR DisplayName = 'Noah Snyder';",
        "SQL": "SELECT T1.DisplayName FROM users AS T1 INNER JOIN postHistory AS T2 ON T1.Id = T2.UserId INNER JOIN posts AS T3 ON T2.PostId = T3.Id WHERE T1.DisplayName = 'Harvey Motulsky' OR T1.DisplayName = 'Noah Snyder' GROUP BY T1.DisplayName ORDER BY SUM(T3.ViewCount) DESC LIMIT 1",
        "difficulty": "challenging",
        "answer": "SELECT OwnerDisplayName, Id, ViewCount FROM posts WHERE OwnerDisplayName IN ('Harvey Motulsky', 'Noah Snyder') ORDER BY ViewCount DESC LIMIT 1",
        "error reason": "Mistook OwnerDisplayName, Id, ViewCount as the target, but the correct target is only DisplayName.",
        "error type": [
            1,
            5
        ]
    },
    {
        "question_id": 29,
        "db_id": "codebase_community",
        "question": "Based on posts posted by Community, calculate the percentage of posts in category 5.",
        "evidence": "We need to select posts from the `posts` table where `OwnerUserId` is -1' which indicates that the post is posted by community.",
        "SQL": "SELECT 100.0 * SUM(CASE WHEN PostTypeId = 5 THEN 1 ELSE 0 END) / COUNT(*) AS percentage FROM posts WHERE OwnerUserId = -1",
        "difficulty": "challenging",
        "answer": "SELECT (SELECT COUNT(*) FROM posts WHERE PostTypeId = 5) * 100.0 / (SELECT COUNT(*) FROM posts) AS PercentageOfPostsInCategory5",
        "error reason": "Missing OwnerUserId = -1, for didn't' realize that `OwnerUserId` is -1' indicates that the post is posted by community. Memory recall failure.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 30,
        "db_id": "codebase_community",
        "question": "Among all the posts posted by the most influential user, identify the percentage with a score above 50.",
        "evidence": "The user with higher reputation has more influence; DIVIDE(COUNT(stats_posts.Id where Score > = 50 and MAX(Reputation))), COUNT(stats_posts.Id where MAX(Reputation)) as percentage;",
        "SQL": "SELECT CAST(SUM(CASE WHEN T2.Score > 50 THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(T1.Id) FROM users T1 INNER JOIN posts T2 ON T1.Id = T2.OwnerUserId INNER JOIN ( SELECT MAX(Reputation) AS max_reputation FROM users ) T3 ON T1.Reputation = T3.max_reputation",
        "difficulty": "challenging",
        "answer": "SELECT (COUNT(CASE WHEN Score > 50 THEN 1 END) * 100.0 / COUNT(*)) AS Percentage_of_Posts_With_Score_Above_50 FROM posts WHERE OwnerUserId = (SELECT Id FROM users ORDER BY Reputation DESC LIMIT 1)",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 31,
        "db_id": "superhero",
        "question": "Between DC and Marvel Comics, which publisher has published more superheroes? Find the difference in the number of superheroes they have published.",
        "evidence": "DC refers to publisher_name = 'DC Comics'; Marvel Comics refers to publisher_name = 'Marvel Comics'; calculation = SUBTRACT(SUM(publisher_name = 'Marvel Comics'), SUM(publisher_name = 'DC Comics'))",
        "SQL": "WITH dc_count AS (SELECT COUNT(*) AS count FROM superhero s JOIN publisher p ON s.publisher_id = p.id WHERE p.publisher_name = 'DC Comics'), mc_count AS (SELECT COUNT(*) AS count FROM superhero s JOIN publisher p ON s.publisher_id = p.id WHERE p.publisher_name = 'Marvel Comics') SELECT CASE WHEN dc_count.count > mc_count.count THEN 'DC Comics' ELSE 'Marvel Comics' END AS publisher_with_more_heroes, ABS(dc_count.count - mc_count.count) AS difference FROM dc_count, mc_count",
        "difficulty": "challenging",
        "answer": "SELECT ABS((SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Marvel Comics')) - (SELECT COUNT(*) FROM superhero WHERE publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'DC Comics'))) AS difference",
        "error reason": "Forgot to answer first half of the question.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 32,
        "db_id": "superhero",
        "question": "In superheroes with height between 150 to 180, what is the percentage of heroes published by Marvel Comics?",
        "evidence": "height between 150 to 180 refers to height_cm BETWEEN 150 AND 180; heroes published by Marvel Comics refers to publisher_id = 13; calculation = MULTIPLY(DIVIDE(SUM(publisher.id = 13)), COUNT(publisher.id), 100)",
        "SQL": "SELECT CAST(COUNT(CASE WHEN T2.publisher_name = 'Marvel Comics' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.height_cm BETWEEN 150 AND 180",
        "difficulty": "challenging",
        "answer": "SELECT (COUNT(CASE WHEN p.publisher_name = 'Marvel Comics' THEN 1 END) * 100.0 / COUNT(*)) AS percentage FROM superhero s JOIN publisher p ON s.publisher_id = p.id WHERE s.height_cm BETWEEN 150 AND 180",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 33,
        "db_id": "superhero",
        "question": "Which superhero has the most durability published by Dark Horse Comics?",
        "evidence": "which superhero refers to superhero_name; most durability refers to MAX(attribute_value) WHERE attribute_name = 'durability'; published by Dark Horse Comics refers to publisher_name = 'Dark Horse Comics';",
        "SQL": "SELECT T1.superhero_name FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T3.id = T2.attribute_id INNER JOIN publisher AS T4 ON T4.id = T1.publisher_id WHERE T4.publisher_name = 'Dark Horse Comics' AND T3.attribute_name = 'Durability' ORDER BY T2.attribute_value DESC LIMIT 1",
        "difficulty": "challenging",
        "answer": "SELECT sh.superhero_name FROM superhero sh JOIN hero_attribute ha ON sh.id = ha.hero_id JOIN attribute a ON ha.attribute_id = a.id WHERE a.attribute_name = 'Durability' AND sh.publisher_id = (SELECT id FROM publisher WHERE publisher_name = 'Dark Horse Comics') ORDER BY ha.attribute_value DESC LIMIT 1",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 34,
        "db_id": "superhero",
        "question": "Which superhero has the same eyes, hair and skin colour? Indicate the publisher of the superhero.",
        "evidence": "which superhero refers to superhero_name; the same eyes, hair and skin colour refers to hair_colour_id = skin_colour_id AND hair_colour_id = eye_colour_id; publisher refers to publisher_name;",
        "SQL": "SELECT T1.superhero_name, T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.eye_colour_id = T1.hair_colour_id AND T1.eye_colour_id = T1.skin_colour_id",
        "difficulty": "challenging",
        "answer": "SELECT s.superhero_name, p.publisher_name FROM superhero s JOIN colour ce ON s.eye_colour_id = ce.id JOIN colour ch ON s.hair_colour_id = ch.id JOIN colour cs ON s.skin_colour_id = cs.id JOIN publisher p ON s.publisher_id = p.id WHERE ce.id = ch.id AND ch.id = cs.id",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 35,
        "db_id": "superhero",
        "question": "What is the percentage of blue female superheroes among all female superheroes?",
        "evidence": "percentage = MULTIPLY(DIVIDE(SUM(colour = 'Blue' WHERE gender = 'Female'), COUNT(gender = 'Female')), 100); blue refers to the color; female refers to gender = 'Female';",
        "SQL": "SELECT CAST(COUNT(CASE WHEN T3.colour = 'Blue' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id INNER JOIN colour AS T3 ON T1.skin_colour_id = T3.id WHERE T2.gender = 'Female'",
        "difficulty": "challenging",
        "answer": "SELECT    (COUNT(CASE WHEN `c`.`colour` = 'Blue' THEN 1 END) * 100.0 / COUNT(*)) AS `percentage` FROM    `superhero` AS `sh` JOIN    `gender` AS `g` ON `sh`.`gender_id` = `g`.`id` JOIN    `colour` AS `c` ON `sh`.`skin_colour_id` = `c`.`id` WHERE    `g`.`gender` = 'Female'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 36,
        "db_id": "superhero",
        "question": "How many percent of female heroes were published by Marvel Comics?",
        "evidence": "percent = MULTIPLY(DIVIDE(SUM(gender = 'Female' WHERE publisher_name = 'Marvel Comics'), COUNT(publisher_name = 'Marvel Comics')), 100); female heroes refers to gender = 'Female'; Marvel Comics refers to publisher_name = 'Marvel Comics';",
        "SQL": "SELECT (CAST(COUNT(*) AS FLOAT) / (SELECT COUNT(*) FROM superhero AS s JOIN gender AS g ON s.gender_id = g.id WHERE g.gender = 'Female')) * 100 AS female_heroes_marvel_percentage FROM superhero AS s JOIN gender AS g ON s.gender_id = g.id JOIN publisher AS p ON s.publisher_id = p.id WHERE g.gender = 'Female' AND p.publisher_name = 'Marvel Comics'",
        "difficulty": "challenging",
        "answer": "SELECT (COUNT(CASE WHEN g.gender = 'Female' THEN 1 END) * 100.0 / (SELECT COUNT(*) FROM superhero AS s JOIN gender AS g ON s.gender_id = g.id WHERE g.gender = 'Female')) AS percentage FROM superhero AS s JOIN publisher AS p ON s.publisher_id = p.id JOIN gender AS g ON s.gender_id = g.id WHERE p.publisher_name = 'Marvel Comics'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 37,
        "db_id": "superhero",
        "question": "Among the bad superheroes, what is the percentage of female superheroes?",
        "evidence": "bad superheroes refers to alignment.id = 2; percentage = MULTIPLY(DIVIDE(SUM(gender.id = 2 WHERE alignment.id = 2), COUNT(alignment.id = 2)), 100.0); female refers to gender.id = 2;",
        "SQL": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN alignment AS T2 ON T1.alignment_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.alignment = 'Bad'",
        "difficulty": "challenging",
        "answer": "SELECT (COUNT(CASE WHEN g.gender = 'Female' THEN 1 END) * 100.0 / COUNT(*)) AS female_percentage FROM superhero h JOIN alignment a ON h.alignment_id = a.id JOIN gender g ON h.gender_id = g.id WHERE a.alignment = 'Bad'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 38,
        "db_id": "superhero",
        "question": "In superheroes with missing weight data, calculate the difference between the number of superheroes with blue eyes and no eye color.",
        "evidence": "missing weight data refers to weight_kg = 0 OR T1.weight_kg = NULL; difference = SUBTRACT(SUM(colour.id = 7), SUM(colour.id = 1)); blue eyes refers to eye_colour_id WHERE colour.id = 7; no eye color refers to eye_colour_id WHERE colour.id = 1;",
        "SQL": "SELECT SUM(CASE WHEN T2.id = 7 THEN 1 ELSE 0 END) - SUM(CASE WHEN T2.id = 1 THEN 1 ELSE 0 END) FROM superhero AS T1 INNER JOIN colour AS T2 ON T1.eye_colour_id = T2.id WHERE T1.weight_kg = 0 OR T1.weight_kg is NULL",
        "difficulty": "challenging",
        "answer": "SELECT COUNT(*) as blue_eyes_count FROM superhero WHERE weight_kg IS NULL AND eye_colour_id = 1",
        "error reason": "Only the number of heroes with blue eyes and missing weight was requested, i.e. only part of the user request was done. Memory recall failure.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 39,
        "db_id": "superhero",
        "question": "Among all superheroes created by George Lucas, identify the percentage of female superheroes.",
        "evidence": "created by George Lucas refers to publisher_name = 'George Lucas'; percentage = MULTIPLY(DIVIDE(SUM(gender = 'Female' WHERE publisher_name = 'George Lucas'), COUNT(publisher_name = 'George Lucas')), 100.0); female refers to gender = 'Female';",
        "SQL": "SELECT CAST(COUNT(CASE WHEN T3.gender = 'Female' THEN 1 ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id INNER JOIN gender AS T3 ON T1.gender_id = T3.id WHERE T2.publisher_name = 'George Lucas'",
        "difficulty": "challenging",
        "answer": "SELECT (COUNT(CASE WHEN g.gender = 'Female' THEN 1 END) * 100.0 / COUNT(s.id)) AS female_percentage FROM superhero s JOIN publisher p ON s.publisher_id = p.id JOIN gender g ON s.gender_id = g.id WHERE p.publisher_name = 'George Lucas'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 40,
        "db_id": "superhero",
        "question": "Among all superheroes in Marvel Comics, identify the percentage of 'good' superheroes.",
        "evidence": "Marvel Comics refers to publisher_name = 'Marvel Comics'; percentage = MULTIPLY(DIVIDE(SUM(alignment = 'Good' WHERE publisher_name = 'Marvel Comics'), COUNT(publisher_name = 'Marvel Comics')), 100.0); good superheroes refers to alignment = 'Good';",
        "SQL": "SELECT CAST(COUNT(CASE WHEN T3.alignment = 'Good' THEN T1.id ELSE NULL END) AS REAL) * 100 / COUNT(T1.id) FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id LEFT JOIN alignment AS T3 ON T1.alignment_id = T3.id WHERE T2.publisher_name = 'Marvel Comics'",
        "difficulty": "challenging",
        "answer": "SELECT (COUNT(CASE WHEN a.alignment = 'Good' THEN 1 END) * 100.0 / COUNT(*)) AS percentage_good FROM superhero s JOIN publisher p ON s.publisher_id = p.id JOIN alignment a ON s.alignment_id = a.id WHERE p.publisher_name = 'Marvel Comics'",
        "error reason": "INNER JOIN (JOIN) with alignment excludes superheroes who do not have an alignment (alignment_id is NULL). As a result, the denominator (COUNT(*)) only includes superheroes with an alignment, not all Marvel superheroes.",
        "error type": [
          3,  
          6
        ]
    },
    {
        "question_id": 41,
        "db_id": "formula_1",
        "question": "Paul di Resta was in the No. 853 race, what percent faster did he finish in the 853rd race than the next race for the fastest lap speed?",
        "evidence": "race number refers to raceId; DIVIDE(SUBTRACT(fastestLapSpeed(raceId = 853), (fastestLapSpeed (raceId = 854)), (fastestLapSpeed(raceId = 854)) as percentage",
        "SQL": "SELECT (SUM(IIF(T2.raceId = 853, T2.fastestLapSpeed, 0)) - SUM(IIF(T2.raceId = 854, T2.fastestLapSpeed, 0))) * 100 / SUM(IIF(T2.raceId = 854, T2.fastestLapSpeed, 0)) FROM drivers AS T1 INNER JOIN results AS T2 ON T2.driverId = T1.driverId WHERE T1.forename = 'Paul' AND T1.surname = 'di Resta'",
        "difficulty": "challenging",
        "answer": "SELECT ((r1.`fastestLapSpeed` - r2.`fastestLapSpeed`) / r2.`fastestLapSpeed`) * 100 AS `percent_faster` FROM results r1 JOIN races ra1 ON r1.`raceId` = ra1.`raceId` JOIN results r2 JOIN races ra2 ON r2.`raceId` = ra2.`raceId` WHERE ra1.`raceId` = 853 AND ra2.`raceId` = (SELECT MIN(`raceId`) FROM races WHERE `raceId` > 853) AND r1.`driverId` = (SELECT `driverId` FROM drivers WHERE `forename` = 'Paul' AND `surname` = 'di Resta') AND r2.`driverId` = r1.`driverId`",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 42,
        "db_id": "formula_1",
        "question": "How much faster in percentage is the champion than the driver who finished the race last in the 2008 Australian Grand Prix?",
        "evidence": "We need to calculate the percentage difference in finishing times between the champion and the driver who finished last in the 2008 Australian Grand Prix. First, we find the `raceId` from the `races` table where `year` is 2008 and `name` is 'Australian Grand Prix'. Then, we select the `milliseconds` of drivers who finished the race (where `position` is not NULL) from the `results` table for that `raceId`. We identify the champion (where `positionOrder` = 1) and the last driver (with the maximum `positionOrder`). Finally, we compute the percentage difference using the formula: `((last_driver_time - champion_time) * 100.0 / last_driver_time)`.",
        "SQL": "WITH race AS (SELECT raceId FROM races WHERE year = 2008 AND name = 'Australian Grand Prix'), finished_results AS (SELECT positionOrder, milliseconds FROM results WHERE raceId = (SELECT raceId FROM race) AND position IS NOT NULL AND milliseconds IS NOT NULL), champion AS (SELECT milliseconds FROM finished_results WHERE positionOrder = 1), last_driver AS (SELECT milliseconds FROM finished_results WHERE positionOrder = (SELECT MAX(positionOrder) FROM finished_results)) SELECT ((last_driver.milliseconds - champion.milliseconds) * 100.0 / last_driver.milliseconds) AS percentage_faster FROM champion, last_driver",
        "difficulty": "challenging",
        "answer": "SELECT (MIN(CAST(substr(time, instr(time, ':') + 1), 'integer')) + CAST(substr(time, 1, instr(time, ':') - 1), 'integer') * 60))/(MAX(CAST(substr(time, instr(time, ':') + 1), 'integer')) + CAST(substr(time, 1, instr(time, ':') - 1), 'integer') * 60) * 100) AS percentage_faster FROM results WHERE raceId = (SELECT raceId FROM races WHERE name = 'Australian Grand Prix' AND year = 2008)",
        "error reason": "substr(time, instr(time, ':') + 1), 'integer') syntax error. There may be a problem with the pre-training data.",
        "error type": [
            3
        ]
    },
    {
        "question_id": 43,
        "db_id": "formula_1",
        "question": "Please calculate the race completion percentage of Japanese drivers from 2007 to 2009.",
        "evidence": "from 2007 to 2009 refers to year between 2007 and 2009; race completion refers to status.status = 'Finished' OR status.status LIKE '+%'; percentage = Divide(COUNT(RaceID where status.status = 'Finished' OR status.status LIKE '+%' and year between 2007 and 2009),Count (RaceID where year between 2007 and 2009))*100;",
        "SQL": "SELECT (CAST(SUM(CASE WHEN status.status = 'Finished' OR status.status LIKE '+%' THEN 1 ELSE 0 END) AS FLOAT) * 100.0) / COUNT(*) AS completion_percentage FROM results JOIN status ON results.statusId = status.statusId WHERE driverId IN (SELECT driverId FROM drivers WHERE nationality = 'Japanese') AND raceId IN (SELECT raceId FROM races WHERE year BETWEEN 2007 AND 2009)",
        "difficulty": "challenging",
        "answer": "SELECT (COUNT(CASE WHEN r.position IS NOT NULL THEN 1 END) * 100.0 / COUNT(r.raceId)) AS completion_percentage FROM results r JOIN drivers d ON r.driverId = d.driverId JOIN races ra ON r.raceId = ra.raceId WHERE d.nationality = 'Japanese' AND ra.year BETWEEN 2007 AND 2009",
        "error reason": "Relying only on position to determine whether the driver has finished race without considering STATUS.",
        "error type": [
          2,  
          7
        ]
    },
    {
        "question_id": 44,
        "db_id": "formula_1",
        "question": "What is the average finish time in seconds of champion for each year?",
        "evidence": "only champion's finished time is represented in milliseconds; finished the game refers to time is not null.",
        "SQL": "SELECT races.year, AVG(results.milliseconds / 1000.0) as average_finish_time_seconds FROM races JOIN results ON races.raceId = results.raceId WHERE results.position = 1 GROUP BY races.year",
        "difficulty": "challenging",
        "answer": "SELECT ra.year, AVG( CAST(SUBSTR(r.time, INSTR(r.time, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(r.time, INSTR(r.time, ':') + 1) AS REAL) AS REAL) ) AS average_finish_time_seconds FROM results AS r JOIN races AS ra ON r.raceId = ra.raceId WHERE r.position = 1 GROUP BY ra.year",
        "error reason": "Syntax involving CAST is not correctly applied. Time handling method here is also not suitable,If the minutes are two digits, this method extracts only the last digit.",
        "error type": [
            3,
            4
        ]
    },
    {
        "question_id": 45,
        "db_id": "formula_1",
        "question": "List down top 5 German drivers who has the shortest average pit stop duration and were born between 1980-1985.",
        "evidence": "born between 1980-1985 refers to 1980< year(dob)>1985; Average pitstop duration refers to Divide(SUM(duration),COUNT(duration)); shortest average refers to Min(avg(duration));",
        "SQL": "SELECT T2.forename, T2.surname FROM pitStops AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId WHERE T2.nationality = 'German' AND STRFTIME('%Y', T2.dob) BETWEEN '1980' AND '1985' GROUP BY T2.forename, T2.surname ORDER BY AVG(T1.duration) LIMIT 5",
        "difficulty": "challenging",
        "answer": "SELECT d.forename, d.surname, AVG(CAST(p.duration AS REAL)) as average_duration FROM drivers d JOIN pitStops p ON d.driverId = p.driverId WHERE d.nationality = 'German' AND d.dob BETWEEN '1980-01-01' AND '1985-12-31' GROUP BY d.driverId ORDER BY average_duration ASC LIMIT 5",
        "error reason": "Over selected AVG(CAST(p.duration AS REAL) for sorting purposes.",
        "error type": [
            5
        ]
    },
    {
        "question_id": 46,
        "db_id": "formula_1",
        "question": "What is the constructor reference name of the champion in the 2009 Singapore Grand Prix? Please give its website.",
        "evidence": "the time of the champion shows in the format of \"minutes: seconds.millionsecond\" in which Max(time); constructor reference name refers to constructorRef; website refers to url",
        "SQL": "SELECT T3.constructorRef, T3.url FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN constructors AS T3 on T1.constructorId = T3.constructorId WHERE T2.name = 'Singapore Grand Prix' AND T2.year = 2009 AND T1.time LIKE '_:%:__.___'",
        "difficulty": "challenging",
        "answer": "SELECT c.`constructorRef`, c.`url` FROM results r JOIN constructors c ON r.`constructorId` = c.`constructorId` JOIN races ra ON r.`raceId` = ra.`raceId` WHERE ra.`name` = 'Singapore Grand Prix' AND ra.`year` = 2009 AND r.`position` = 1",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 47,
        "db_id": "formula_1",
        "question": "Which constructor scored most points from Monaco Grand Prix between 1980 and 2010? List the score, name and nationality of this team.",
        "evidence": "Monaco Grand Priz refers to the race; race in year between 1980 and 2010",
        "SQL": "SELECT SUM(T1.points), T2.name, T2.nationality FROM constructorResults AS T1 INNER JOIN constructors AS T2 ON T1.constructorId = T2.constructorId INNER JOIN races AS T3 ON T3.raceid = T1.raceid WHERE T3.name = 'Monaco Grand Prix' AND T3.year BETWEEN 1980 AND 2010 GROUP BY T2.name ORDER BY SUM(T1.points) DESC LIMIT 1",
        "difficulty": "challenging",
        "answer": "SELECT SUM(cr.points) AS score, c.name, c.nationality  FROM races r  JOIN constructorResults cr ON r.raceId = cr.raceId  JOIN constructors c ON cr.constructorId = c.constructorId  WHERE r.name LIKE '%Monaco Grand Prix%' AND r.year BETWEEN 1980 AND 2010  GROUP BY c.constructorId  ORDER BY score DESC  LIMIT 1",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 48,
        "db_id": "formula_1",
        "question": "What is full name of the racer who ranked 1st in the 3rd qualifying race held in the Marina Bay Street Circuit in 2008?",
        "evidence": "Ranked 1st in the 3rd qualifying race refer to MIN(q3); 2008 is the year of race; full name of racer = forename, surname",
        "SQL": "SELECT T2.forename, T2.surname FROM qualifying AS T1 INNER JOIN drivers AS T2 on T1.driverId = T2.driverId INNER JOIN races AS T3 ON T1.raceid = T3.raceid WHERE q3 IS NOT NULL AND T3.year = 2008 AND T3.circuitId IN ( SELECT circuitId FROM circuits WHERE name = 'Marina Bay Street Circuit' ) ORDER BY CAST(SUBSTR(q3, 1, INSTR(q3, ':') - 1) AS INTEGER) * 60 + CAST(SUBSTR(q3, INSTR(q3, ':') + 1, INSTR(q3, '.') - INSTR(q3, ':') - 1) AS REAL) + CAST(SUBSTR(q3, INSTR(q3, '.') + 1) AS REAL) / 1000 ASC LIMIT 1",
        "difficulty": "challenging",
        "answer": "SELECT d.`forename`, d.`surname` FROM qualifying q JOIN races r ON q.`raceId` = r.`raceId` JOIN drivers d ON q.`driverId` = d.`driverId` WHERE q.`position` = 1 AND r.`name` = 'Singapore Grand Prix' AND r.`year` = 2008",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 49,
        "db_id": "formula_1",
        "question": "In the race a driver set the lap record for the Austrian Grand Prix circuit, how long in seconds did he spent at the pit stop at that same race? Retain the decimal part.",
        "evidence": "lap record means the fastest time recorded which refers to time, how long spent at pitstop refers to duration",
        "SQL": "WITH fastest_lap_times AS ( SELECT T1.raceId, T1.driverId, T1.FastestLapTime, (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) as time_in_seconds FROM results AS T1 WHERE T1.FastestLapTime IS NOT NULL), lap_record_race AS ( SELECT T1.raceId, T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId INNER JOIN ( SELECT MIN(fastest_lap_times.time_in_seconds) as min_time_in_seconds FROM fastest_lap_times INNER JOIN races AS T2 on fastest_lap_times.raceId = T2.raceId INNER JOIN circuits AS T3 on T2.circuitId = T3.circuitId WHERE T2.name = 'Austrian Grand Prix') AS T4 ON (CAST(SUBSTR(T1.FastestLapTime, 1, INSTR(T1.FastestLapTime, ':') - 1) AS REAL) * 60) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, ':') + 1, INSTR(T1.FastestLapTime, '.') - INSTR(T1.FastestLapTime, ':') - 1) AS REAL)) + (CAST(SUBSTR(T1.FastestLapTime, INSTR(T1.FastestLapTime, '.') + 1) AS REAL) / 1000) = T4.min_time_in_seconds WHERE T2.name = 'Austrian Grand Prix') SELECT CAST(T4.duration AS REAL) FROM lap_record_race INNER JOIN pitStops AS T4 on lap_record_race.raceId = T4.raceId AND lap_record_race.driverId = T4.driverId",
        "difficulty": "challenging",
        "answer": "SELECT duration FROM pitStops WHERE raceId = (SELECT raceId FROM races WHERE name = 'Austrian Grand Prix')",
        "error reason": "Multiple conditions such as driver ranking are missing. Unable to handle complex requests, memory recall fails.",
        "error type": [
          2,
          5
        ]
    },
    {
        "question_id": 50,
        "db_id": "european_football_2",
        "question": "In Scotland Premier League, which away team won the most during the 2010 to 2011 season?",
        "evidence": "Scotland Premier League refers to League.name = 'Scotland Premier League'; away team refers to away_team_api_id; away team that won the most refers to MAX(SUBTRACT(away_team_goal, home_team_goal) > 0); 2010 season refers to season = '2010/2011';",
        "SQL": "SELECT teamInfo.team_long_name FROM League AS leagueData INNER JOIN Match AS matchData ON leagueData.id = matchData.league_id INNER JOIN Team AS teamInfo ON matchData.away_team_api_id = teamInfo.team_api_id WHERE leagueData.name = 'Scotland Premier League' AND matchData.season = '2010/2011' AND matchData.away_team_goal - matchData.home_team_goal > 0 GROUP BY matchData.away_team_api_id ORDER BY COUNT(*) DESC LIMIT 1",
        "difficulty": "challenging",
        "answer": "SELECT away_team_api_id, COUNT(*) AS wins FROM Match JOIN League ON Match.league_id = League.id WHERE League.name = 'Scotland Premier League' AND Match.season = '2010/2011' AND away_team_goal > home_team_goal GROUP BY away_team_api_id ORDER BY wins DESC LIMIT 1",
        "error reason": "Overselected wins for sorting purposes; output away_team_api_id instead of team name. Semantic misunderstanding.",
        "error type": [
            1,
            5
        ]
    },
    {
        "question_id": 51,
        "db_id": "european_football_2",
        "question": "At present, calculate for the player's age who have a sprint speed of no less than 97 between 2013 to 2015.",
        "evidence": "players age at present = SUBTRACT((DATETIME(), birthday)); sprint_speed > = 97; between 2013 to 2015 refers to date > = '2013-01-01 00:00:00' AND date < = '2015-12-31 00:00:00';",
        "SQL": "SELECT DISTINCT  (CAST(strftime('%Y',current_timestamp) AS INTEGER) - CAST(strftime('%Y', T2.birthday) AS INTEGER)) - CAST(strftime('%m-%d', current_timestamp) < strftime('%m-%d', T2.birthday) AS INTEGER) AS age FROM Player_Attributes AS t1 INNER JOIN Player AS t2 ON t1.player_api_id = t2.player_api_id WHERE SUBSTR(t1.`date`, 1, 10) BETWEEN '2013-01-01' AND '2015-12-31' AND t1.sprint_speed >= 97",
        "difficulty": "challenging",
        "answer": "SELECT strftime('%Y', 'now') - strftime('%Y', birthday) AS age FROM Player p JOIN Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id WHERE pa.sprint_speed >= 97 AND pa.date BETWEEN '2013-01-01 00:00:00' AND '2015-12-31 00:00:00'",
        "error reason": "The age calculation didn't take exact date into account, which leads to inprecise age; also forgot to use DISTINCT on age.",
        "error type": [
            4,
            5
        ]
    },
    {
        "question_id": 52,
        "db_id": "european_football_2",
        "question": "List the long name of teams with above-average build-up play passing in 2012.",
        "evidence": "long name of teams refers to team_long_name; build-up play passing refers to buildUpPlayPassing; above-average build-up play passing = DIVIDE(SUM(buildUpPlayPassing), COUNT(team_long_name) WHERE buildUpPlayPassing IS NOT NULL) < buildUpPlayPassing; in 2012 refers to strftime('%Y', date) = '2012';",
        "SQL": "SELECT DISTINCT t4.team_long_name FROM Team_Attributes AS t3 INNER JOIN Team AS t4 ON t3.team_api_id = t4.team_api_id WHERE SUBSTR(t3.`date`, 1, 4) = '2012' AND t3.buildUpPlayPassing > ( SELECT CAST(SUM(t2.buildUpPlayPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE SUBSTR(t2.`date`, 1, 4) = '2012' )",
        "difficulty": "challenging",
        "answer": "SELECT t.`team_long_name` FROM Team t JOIN Team_Attributes ta ON t.`team_api_id` = ta.`team_api_id` WHERE ta.`buildUpPlayPassing` > (SELECT AVG(ta2.`buildUpPlayPassing`) FROM Team_Attributes ta2 WHERE ta2.`date` LIKE '2012%')",
        "error reason": "Missing DISTINCT.",
        "error type": [
            5
        ]
    },
    {
        "question_id": 53,
        "db_id": "european_football_2",
        "question": "For the teams with normal build-up play dribbling class in 2014, List the names of the teams with less than average chance creation passing, in descending order of chance creation passing.",
        "evidence": "normal build-up play dribbling class refers to buildUpPlayDribblingClass = 'Normal'; in 2014 refers to date > = '2014-01-01 00:00:00' AND date < = '2014-01-31 00:00:00'; names of the teams refers to team_long_name; less than average chance creation passing = DIVIDE(SUM(chanceCreationPassing), COUNT(id)) > chanceCreationPassing;",
        "SQL": "SELECT DISTINCT t3.team_long_name FROM Team AS t3 INNER JOIN Team_Attributes AS t4 ON t3.team_api_id = t4.team_api_id WHERE t4.buildUpPlayDribblingClass = 'Normal' AND SUBSTR(t4.`date`, 1, 4) = '2014' AND t4.chanceCreationPassing < ( SELECT CAST(SUM(t2.chanceCreationPassing) AS REAL) / COUNT(t1.id) FROM Team AS t1 INNER JOIN Team_Attributes AS t2 ON t1.team_api_id = t2.team_api_id WHERE t2.buildUpPlayDribblingClass = 'Normal' AND SUBSTR(t2.`date`, 1, 4) = '2014') ORDER BY t4.chanceCreationPassing DESC",
        "difficulty": "challenging",
        "answer": "SELECT t.team_long_name FROM Team t JOIN Team_Attributes ta ON t.team_api_id = ta.team_api_id WHERE ta.buildUpPlayDribblingClass = 'Normal' AND ta.date LIKE '2014%' AND ta.chanceCreationPassing < (SELECT AVG(chanceCreationPassing) FROM Team_Attributes WHERE date LIKE '2014%') ORDER BY ta.chanceCreationPassing DESC",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 54,
        "db_id": "european_football_2",
        "question": "List the name of leagues in which the average goals by the home team is higher than the away team in the 2009/2010 season.",
        "evidence": "name of league refers to League.name; average goals by the home team is higher than the away team = AVG(home_team_goal) > AVG(away_team_goal);",
        "SQL": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2009/2010' GROUP BY t1.name HAVING (CAST(SUM(t2.home_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) - (CAST(SUM(t2.away_team_goal) AS REAL) / COUNT(DISTINCT t2.id)) > 0",
        "difficulty": "challenging",
        "answer": "SELECT DISTINCT L.name FROM Match M JOIN League L ON M.league_id = L.id WHERE M.season = '2009/2010' GROUP BY L.id HAVING AVG(M.home_team_goal) > AVG(M.away_team_goal)",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 55,
        "db_id": "european_football_2",
        "question": "What is the difference of the average ball control score between Abdou Diallo and Aaron Appindangoye\n?",
        "evidence": "difference of the average ball control = SUBTRACT(AVG(ball_control WHERE player_name = 'Abdou Diallo'),\u00a0AVG(ball_control WHERE player_name = 'Aaron Appindangoye'));",
        "SQL": "SELECT CAST(SUM(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Abdou Diallo' THEN t2.id ELSE NULL END) - CAST(SUM(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.ball_control ELSE 0 END) AS REAL) / COUNT(CASE WHEN t1.player_name = 'Aaron Appindangoye' THEN t2.id ELSE NULL END) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id",
        "difficulty": "challenging",
        "answer": "SELECT (SELECT AVG(ball_control) FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Abdou Diallo')) - (SELECT AVG(ball_control) FROM Player_Attributes WHERE player_api_id = (SELECT player_api_id FROM Player WHERE player_name = 'Aaron Appindangoye')) AS score_difference",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 56,
        "db_id": "european_football_2",
        "question": "What was the average overall rating for Marko Arnautovic from 2007/2/22 to 2016/4/21?",
        "evidence": "average overall rating refers to avg(overall_rating); Marko Arnautovic refers to player_name = 'Marko Arnautovic'; from 2007/2/22 to 2016/4/21 refers to date BETWEEN '2007-02-22 00:00:00' and '2016-04-21 00:00:00'",
        "SQL": "SELECT CAST(SUM(t2.overall_rating) AS REAL) / COUNT(t2.id) FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE t1.player_name = 'Marko Arnautovic' AND SUBSTR(t2.`date`, 1, 10) BETWEEN '2007-02-22' AND '2016-04-21'",
        "difficulty": "challenging",
        "answer": "SELECT AVG(pa.overall_rating) FROM Player p JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE p.player_name = 'Marko Arnautovic' AND pa.date BETWEEN '2007-02-22' AND '2016-04-21'",
        "error reason": "pa.date BETWEEN '2007-02-22' AND '2016-04-21' can't capture data like '2016-04-21 00:00:00', thus resulting in data loss.",
        "error type": [
            4
        ]
    },
    {
        "question_id": 57,
        "db_id": "european_football_2",
        "question": "What percentage is Landon Donovan's overall rating higher than Jordan Bowery on 2013/7/12?",
        "evidence": "Landon Donovan's refers to player_name = 'Landon Donovan'; Jordan Bowery refers to player_name = 'Jordan Bowery';\u00a0 percentage refers to DIVIDE(SUBTRACT(player_name = 'Landon Donovan' overall_rating; player_name = 'Jordan Bowery' overall_rating), player_name = 'Jordan Bowery' overall_rating)*100",
        "SQL": "SELECT (SUM(CASE WHEN t1.player_name = 'Landon Donovan' THEN t2.overall_rating ELSE 0 END) * 1.0 - SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END)) * 100 / SUM(CASE WHEN t1.player_name = 'Jordan Bowery' THEN t2.overall_rating ELSE 0 END) LvsJ_percent FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_fifa_api_id = t2.player_fifa_api_id WHERE SUBSTR(t2.`date`, 1, 10) = '2013-07-12'",
        "difficulty": "challenging",
        "answer": "SELECT ((Landon.rating - Jordan.rating) * 100.0 / Jordan.rating) AS percentage_difference FROM  (SELECT p.player_api_id, pa.overall_rating AS rating   FROM Player p   JOIN Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id   WHERE p.player_name = 'Landon Donovan' AND pa.date = '2013-07-12') AS Landon, (SELECT p.player_api_id, pa.overall_rating AS rating   FROM Player p   JOIN Player_Attributes pa ON p.player_fifa_api_id = pa.player_fifa_api_id   WHERE p.player_name = 'Jordan Bowery' AND pa.date = '2013-07-12') AS Jordan",
        "error reason": "If there are multiple records for either player on the specified date, the number of resulting rows multiplies, leading to incorrect calculations. Also the date handling is not sufficient to capture data like '2013-07-12 15:30:00'.",
        "error type": [
            4,
            5
        ]
    },
    {
        "question_id": 58,
        "db_id": "thrombosis_prediction",
        "question": "For in-patient age 50 and above, what is their average anti-cardiolipin antibody (IgG) concentration?",
        "evidence": "in-patient refers to Admission = '+'; age 50 and above refers to SUBTRACT(year(current_timestamp), year(Birthday)) >= '50'; average anti-cardiolipin antibody (IgG) concentration refers to AVG(aCL IgG)",
        "SQL": "SELECT AVG(T2.`aCL IgG`) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE (strftime('%Y', 'now') - strftime('%Y', T1.Birthday)) - (strftime('%m-%d', 'now') < strftime('%m-%d', T1.Birthday)) >= 50 AND T1.Admission = '+'",
        "difficulty": "challenging",
        "answer": "SELECT AVG(`aCL IgG`) FROM Examination INNER JOIN Patient ON Examination.ID = Patient.ID WHERE (julianday('now') - julianday(Patient.Birthday)) / 365.25 >= 50 AND Patient.Admission = '+'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 59,
        "db_id": "thrombosis_prediction",
        "question": "What is the ratio of male to female patients among all those with abnormal uric acid counts?",
        "evidence": "male refers to SEX = 'M'; female refers to SEX = 'F'; abnormal uric acid refers to UA < = '8.0' where SEX = 'M', UA < = '6.5' where SEX = 'F'; calculation = DIVIDE(SUM(UA <= '8.0' and SEX = 'M'), SUM(UA <= '6.5 and SEX = 'F'))",
        "SQL": "SELECT CAST(SUM(CASE WHEN T2.UA <= 8.0 AND T1.SEX = 'M' THEN 1 ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.UA <= 6.5 AND T1.SEX = 'F' THEN 1 ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID",
        "difficulty": "challenging",
        "answer": "SELECT (SELECT COUNT(*) FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.UA > 8.0 AND p.SEX = 'M') AS Male_Count, (SELECT COUNT(*) FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.UA > 6.5 AND p.SEX = 'F') AS Female_Count",
        "error reason": "Didn't count the ratio but only count the numbers. Also didn't follow the data description of UA, which indicates that IA > 8.0 means normal. Memory recall failure.",
        "error type": [
          2,
          7
        ]
    },
    {
        "question_id": 60,
        "db_id": "thrombosis_prediction",
        "question": "What is the most common illness that doctors identified among the patients whose lab work was done between 1/1/1985, and 12/31/1995?",
        "evidence": "the most common illness refers to MAX(COUNT(Diagnosis)); lab work between 1/1/1985 and 12/31/1995 refers to `Examination Date` between '1985-01-01' and '1995-12-31 '",
        "SQL": "SELECT T2.Diagnosis FROM Examination AS T1 INNER JOIN Patient AS T2 ON T1.ID = T2.ID WHERE T1.`Examination Date` BETWEEN '1985-01-01' AND '1995-12-31' GROUP BY T2.Diagnosis ORDER BY COUNT(T2.Diagnosis) DESC LIMIT 1",
        "difficulty": "challenging",
        "answer": "SELECT Diagnosis FROM Patient WHERE ID IN (SELECT ID FROM Laboratory WHERE Date BETWEEN '1985-01-01' AND '1995-12-31') GROUP BY Diagnosis ORDER BY COUNT(*) DESC LIMIT 1",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 61,
        "db_id": "thrombosis_prediction",
        "question": "For the patient who was born on 1959/2/18, what is the decrease rate for his/her total cholesterol from November to December in 1981?",
        "evidence": "born on 1959/2/18 refers to Birthday = '1959-02-18'; calculation = SUBTRACT(SUM(Birthday = '1959-02-18' and Date like '1981-11-%' THEN `T-CHO`), SUM(Birthday = '1959-02-18' and Date like '1981-12-%' THEN `T-CHO`))",
        "SQL": "SELECT CAST((SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.`T-CHO` ELSE 0 END) - SUM(CASE WHEN T2.Date LIKE '1981-12-%' THEN T2.`T-CHO` ELSE 0 END)) AS REAL) / SUM(CASE WHEN T2.Date LIKE '1981-11-%' THEN T2.`T-CHO` ELSE 0 END) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T1.Birthday = '1959-02-18'",
        "difficulty": "challenging",
        "answer": "SELECT ((Nov.TCHO - Dec.TCHO) / Nov.TCHO) * 100 AS `Decrease Rate` FROM Laboratory AS Nov JOIN Patient AS P ON Nov.ID = P.ID JOIN Laboratory AS Dec ON Nov.ID = Dec.ID WHERE P.Birthday = '1959-02-18' AND Nov.Date = '1981-11-01' AND Dec.Date = '1981-12-01'",
        "error reason": "Nov has no TCHO column, because with Nov.Date = '1981-11-01' AND Dec.Date = '1981-12-01' only data on these two days instead of the whole Nov and Dec were selected. It didn't follow the requirement of user,which is memory recall failure.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 62,
        "db_id": "thrombosis_prediction",
        "question": "What percentage of patients with a proteinuria level within the normal range once have a uric acid level below the normal range?",
        "evidence": "proteinuria level within the normal range refers to `U-PRO` > 0 AND `U-PRO` < 30; uric acid level below the normal range refers to SEX = 'F' and UA < = 6.5 and SEX = 'M' and UA < 8.0",
        "SQL": "WITH Patients_UPro_Normal AS (SELECT DISTINCT ID FROM Laboratory WHERE (CAST(\"U-PRO\" AS REAL) > 0 AND CAST(\"U-PRO\" AS REAL) < 30)), Patients_UA_Below_Normal AS (SELECT DISTINCT L.ID FROM Laboratory L JOIN Patient P ON L.ID = P.ID WHERE P.SEX IN ('M', 'F') AND ((P.SEX = 'M' AND L.UA IS NOT NULL AND L.UA < 8.0) OR (P.SEX = 'F' AND L.UA IS NOT NULL AND L.UA < 6.5))), Patients_Both AS (SELECT ID FROM Patients_UPro_Normal WHERE ID IN (SELECT ID FROM Patients_UA_Below_Normal)) SELECT ROUND(100.0 * (SELECT COUNT(*) FROM Patients_Both) / (SELECT COUNT(*) FROM Patients_UPro_Normal), 2) AS Percentage",
        "difficulty": "challenging",
        "answer": "SELECT COUNT(*) * 100.0 / (SELECT COUNT(*) FROM Laboratory WHERE `U-PRO` NOT LIKE '%' LIMIT 30) AS percentage FROM Laboratory WHERE `U-PRO` < 30 AND `UA` < 8.0",
        "error reason": "Mistaken 'a proteinuria level within the normal range' for `U-PRO` NOT LIKE '%' LIMIT 30. Ignored UA normal range difference between male and female. Ignored DISTINCT when counting number of patents. Memory recall failure.",
        "error type": [
            1,
            2,
            5
        ]
    },
    {
        "question_id": 63,
        "db_id": "thrombosis_prediction",
        "question": "What sex is the patient who in a medical examination was diagnosed with PSS and in a laboratory examination had a blood level of C-reactive protein de 2+, createnine 1 and LDH 123?",
        "evidence": "PSS' refers to diagnosis; blood level of C-reactive protein de 2+refers to CRP > 2; createnine 1 refers to CRE = 1; LDH 123 refers to LDH = 123",
        "SQL": "SELECT T1.SEX FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID INNER JOIN Laboratory AS T3 ON T3.ID = T2.ID WHERE T2.Diagnosis = 'PSS' AND T3.CRP = '2+' AND T3.CRE = 1.0 AND T3.LDH = 123",
        "difficulty": "challenging",
        "answer": "SELECT p.`SEX` FROM Patient p INNER JOIN Examination e ON p.`ID` = e.`ID` INNER JOIN Laboratory l ON p.`ID` = l.`ID` WHERE e.`Diagnosis` = 'PSS' AND l.`CRP` = '2+' AND l.`CRE` = 1 AND l.`LDH` = 123",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 64,
        "db_id": "thrombosis_prediction",
        "question": "How many male patients who underwent testing between 1995 and 1997 and were subsequently diagnosed with BEHCET disease did not stay in the hospital for treatment?",
        "evidence": "male refers to SEX = 'M'; underwent testing between 1995 and 1997 refers to `Examination Date` between '1995' and '1997'; BEHCET refers to diagnosis; did not stay in the hospital refers to Admission = '-'",
        "SQL": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Examination AS T2 ON T1.ID = T2.ID WHERE T2.Diagnosis = 'Behcet' AND T1.SEX = 'M' AND STRFTIME('%Y', T2.`Examination Date`) BETWEEN '1995' AND '1997' AND T1.Admission = '-'",
        "difficulty": "challenging",
        "answer": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Examination e ON p.ID = e.ID WHERE p.SEX = 'M' AND e.`Examination Date` BETWEEN '1995-01-01' AND '1997-12-31' AND p.Diagnosis = 'BEHCET' AND p.Admission = '-'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 65,
        "db_id": "thrombosis_prediction",
        "question": "Are there more male patients once with creatinine not within the normal range than female? True or False?",
        "evidence": "creatinine (CRE) not within the normal range refers to CRE > = 1.5; male refers to Sex = 'M'; female refers to Sex = 'F'; calculation = (SUM(SEX = 'M') > SUM(SEX = 'F')) where CRE > = 1.5",
        "SQL": "WITH AbnormalCreatininePatients AS (SELECT DISTINCT Patient.`ID`, Patient.`SEX` FROM Patient JOIN Laboratory ON Patient.`ID` = Laboratory.`ID` WHERE Laboratory.`CRE` >= 1.5 AND Patient.`SEX` IN ('M', 'F')) SELECT CASE WHEN (SELECT COUNT(*) FROM AbnormalCreatininePatients WHERE `SEX` = 'M') > (SELECT COUNT(*) FROM AbnormalCreatininePatients WHERE `SEX` = 'F') THEN 'True' ELSE 'False' END",
        "difficulty": "challenging",
        "answer": "SELECT CASE WHEN (SELECT COUNT(*) FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE p.SEX = 'M' AND l.CRE >= 1.5) > (SELECT COUNT(*) FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE p.SEX = 'F' AND l.CRE >= 1.5) THEN 'True' ELSE 'False' END AS Result",
        "error reason": "Incorrectly using CASE instead of DISTINCT Patient.`ID` to count the number of patients, this means if a patient has multiple lab records with CRE \u2265 1.5, they are counted multiple times. ",
        "error type": [
            5
        ]
    },
    {
        "question_id": 66,
        "db_id": "thrombosis_prediction",
        "question": "For patient born between 1936-1956, how many male patients have creatinine phosphokinase beyond the normal range?",
        "evidence": "born between 1936-1956 refers to year(Birthday) BETWEEN '1936' AND '1956'; male patients refers to sex = 'M'; creatinine phosphokinase beyond the normal range refers to CPK > = 250;",
        "SQL": "SELECT COUNT(DISTINCT T1.ID) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE STRFTIME('%Y', T1.Birthday) BETWEEN '1936' AND '1956' AND T1.SEX = 'M' AND T2.CPK >= 250",
        "difficulty": "challenging",
        "answer": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE p.SEX = 'M' AND p.Birthday BETWEEN '1936-01-01' AND '1956-12-31' AND l.CPK >= 250",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 67,
        "db_id": "thrombosis_prediction",
        "question": "Provide ID, sex and age of patient who once has blood glucose (GLU) not within normal range but with total cholesterol(T-CHO) within normal range.",
        "evidence": "age = (julianday(CURRENT_TIMESTAMP) - julianday(T1.Birthday))/365.25; blood glucose (GLU) not within normal range refers to GLU > = 180; total cholesterol(T-CHO) within normal range refers to `T-CHO` < 250;",
        "SQL": "SELECT DISTINCT T1.ID, T1.SEX , (strftime('%Y', CURRENT_TIMESTAMP) - strftime('%Y', T1.Birthday)) - (strftime('%m-%d', CURRENT_TIMESTAMP) < strftime('%m-%d',T1. Birthday))  FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.GLU >= 180 AND T2.`T-CHO` < 250",
        "difficulty": "challenging",
        "answer": "SELECT Patient.ID, Patient.SEX, strftime('%Y', 'now') - strftime('%Y', Patient.Birthday) AS AGE FROM Patient JOIN Laboratory ON Patient.ID = Laboratory.ID WHERE Laboratory.GLU >= 180 AND Laboratory.T_CHO < 250",
        "error reason": "Incorrect Column Name for T-CHO (mistaken for T_CHO) and missing DISTINCT for Patient.ID. Memory recall failure.",
        "error type": [
            2,
            5
        ]
    },
    {
        "question_id": 68,
        "db_id": "thrombosis_prediction",
        "question": "For laboratory examinations take in 1984, list all patients below 50 years old with normal platelet level at that time.",
        "evidence": "laboratory examinations take in 1984 refers to Date like '1984%'; below 50 years old = (julianday(T2.Date) - julianday(T1.Birthday))/365.25 < 50; normal platelet level refers to PLT between 100 and 400;",
        "SQL": "SELECT DISTINCT T1.ID FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PLT BETWEEN 100 AND 400 AND (strftime('%Y', T2.Date) - strftime('%Y', T1.Birthday)) - (strftime('%m-%d', T2.Date) < strftime('%m-%d',T1. Birthday))  < 50 AND STRFTIME('%Y', T2.Date) = '1984'",
        "difficulty": "challenging",
        "answer": "SELECT p.ID, strftime('%Y', 'now') - strftime('%Y', p.Birthday) AS Age, l.PLT FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.Date BETWEEN '1984-01-01' AND '1984-12-31' AND (strftime('%Y', 'now') - strftime('%Y', p.Birthday)) < 50 AND l.PLT BETWEEN 100 AND 400",
        "error reason": "Incorrect Age Reference. The required age is the age when the examination was executed, not now.",
        "error type": [
            1
        ]
    },
    {
        "question_id": 69,
        "db_id": "thrombosis_prediction",
        "question": "For all patients who are older than 55 years old, what is the percentage of female who has abnormal prothrombin time (PT)?",
        "evidence": "older than 55 years old = SUBTRACT(year(current_timestamp), year(Birthday)) > 55; percentage = MULTIPLY(DIVIDE(SUM(PT > = 14 AND SEX = 'F'), SUM(PT > = 14)), 1.0); female refers to Sex = 'F'; abnormal prothrombin time (PT) refers to PT > = 14;",
        "SQL": "WITH total_patients AS (SELECT COUNT(DISTINCT `ID`) AS total FROM Patient WHERE (strftime('%Y', 'Now') - strftime('%Y', Birthday)) - (strftime('%m-%d', 'Now') < strftime('%m-%d',Birthday)) > 55), female_abnormal_pt AS (SELECT COUNT(DISTINCT Patient.`ID`) AS female_abnormal_count FROM Patient JOIN Laboratory ON Patient.`ID` = Laboratory.`ID` WHERE (strftime('%Y', 'Now') - strftime('%Y', Birthday)) - (strftime('%m-%d', 'Now') < strftime('%m-%d',Birthday)) > 55 AND SEX = 'F' AND PT IS NOT NULL AND PT >= 14) SELECT (female_abnormal_count * 100.0) / total AS percentage FROM total_patients, female_abnormal_pt",
        "difficulty": "challenging",
        "answer": "SELECT (COUNT(CASE WHEN L.PT >= 14 AND P.SEX = 'F' THEN 1 END) * 100.0 / COUNT(CASE WHEN P.SEX = 'F' THEN 1 END)) AS female_abnormal_pt_percentage FROM Patient P JOIN Laboratory L ON P.ID = L.ID WHERE (julianday('now') - julianday(P.Birthday)) / 365 > 55",
        "error reason": "Patients with multiple lab records are counted multiple times without DISTINCT due to the JOIN; Divides by the count of female patients over 55 instead of all patients over 55; Fails to use COUNT(DISTINCT ...), leading to inflated counts. Semantic misunderstanding.",
        "error type": [
            1,
            5
        ]
    },
    {
        "question_id": 70,
        "db_id": "thrombosis_prediction",
        "question": "Among the patients whose C-reactive protein level is abnormal, how many of them aren't 18 yet when their C-reactive protein level was measured?",
        "evidence": "C-reactive protein level is abnormal refers to CRP NOT IN('+-', '-') AND CRP > = 1.0; aren't 18 refers = CRP > = 1.0 AND SUBTRACT((YEAR(CURDATE()), YEAR(Birthday))) < 18; Should compute the number of distinct ones.",
        "SQL": "SELECT COUNT(DISTINCT Laboratory.`ID`) FROM Laboratory JOIN Patient ON Laboratory.`ID` = Patient.`ID` WHERE Laboratory.`CRP` IS NOT NULL AND Laboratory.`Date` IS NOT NULL AND Patient.`Birthday` IS NOT NULL AND Laboratory.`CRP` NOT IN ('-', '+-') AND ((CAST(Laboratory.`CRP` AS REAL) >= 1.0) OR (Laboratory.`CRP` >= '>1.0' AND Laboratory.`CRP` NOT GLOB '[0-9.]*')) AND (strftime('%Y', Laboratory.Date) - strftime('%Y', Birthday)) - (strftime('%m-%d', Laboratory.Date) < strftime('%m-%d',Birthday)) < 18",
        "difficulty": "challenging",
        "answer": "SELECT COUNT(DISTINCT p.ID) FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE l.CRP NOT IN ('-', '+') AND (julianday(l.Date) - julianday(p.Birthday)) / 365.25 < 18",
        "error reason": "Failed to consider special data formats in field CRP like '>1.0'.",
      "error type": [
        6
      ]
    },
    {
        "question_id": 71,
        "db_id": "student_club",
        "question": "How many times was the budget in Advertisement for \"Yearly Kickoff\" meeting more than \"October Meeting\"?",
        "evidence": "DIVIDE(SUM(amount where category = 'Advertisement' and event_name = 'Yearly Kickoff'), SUM(amount event_name = 'October Meeting' and category = 'Advertisement'))",
        "SQL": "SELECT CAST(SUM(CASE WHEN T2.event_name = 'Yearly Kickoff' THEN T1.amount ELSE 0 END) AS REAL) / SUM(CASE WHEN T2.event_name = 'October Meeting' THEN T1.amount ELSE 0 END) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T1.category = 'Advertisement' AND T2.type = 'Meeting'",
        "difficulty": "challenging",
        "answer": "SELECT (B1.amount * 1.0 / B2.amount) AS times_more  FROM Budget B1  JOIN Event E1 ON B1.link_to_event = E1.event_id  JOIN Budget B2  JOIN Event E2 ON B2.link_to_event = E2.event_id  WHERE E1.event_name = 'Yearly Kickoff' AND E2.event_name = 'October Meeting'  AND B1.category = 'Advertisement' AND B2.category = 'Advertisement'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 72,
        "db_id": "student_club",
        "question": "What is the name of the social event that was attended by the vice president of the Student_Club located at 900 E. Washington St.?",
        "evidence": "name of social event refers to event_name where type = 'Social'; 'Vice President' is position; located at refers to location",
        "SQL": "SELECT T2.event_name FROM attendance AS T1 INNER JOIN event AS T2 ON T2.event_id = T1.link_to_event INNER JOIN member AS T3 ON T1.link_to_member = T3.member_id WHERE T3.position = 'Vice President' AND T2.location = '900 E. Washington St.' AND T2.type = 'Social'",
        "difficulty": "challenging",
        "answer": "SELECT E.event_name FROM Attendance A JOIN Event E ON A.link_to_event = E.event_id JOIN Member M ON A.link_to_member = M.member_id WHERE E.type = 'Social' AND E.location = '900 E. Washington St.' AND M.position = 'Vice President'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 73,
        "db_id": "student_club",
        "question": "Among the members who incurred expenses in more than one event, who paid the most amount? Indicate his or her id",
        "evidence": "paid the most amount refers to for expense incurred in more than one event refers to MAX(cost where COUNT(event_id) > 1)",
        "SQL": "SELECT T2.member_id FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id INNER JOIN budget AS T3 ON T1.link_to_budget = T3.budget_id INNER JOIN event AS T4 ON T3.link_to_event = T4.event_id GROUP BY T2.member_id HAVING COUNT(DISTINCT T4.event_id) > 1 ORDER BY SUM(T1.cost) DESC LIMIT 1",
        "difficulty": "challenging",
        "answer": "SELECT link_to_member FROM Expense GROUP BY link_to_member HAVING COUNT(DISTINCT link_to_budget) > 1 ORDER BY SUM(cost) DESC LIMIT 1",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 74,
        "db_id": "student_club",
        "question": "Give the full name and contact number of members who had to spend more than average on each expense.",
        "evidence": "full name refers to first_name, last_name; contact number refers to phone; had spent more than average on each expense refers to cost > AVG(cost)",
        "SQL": "SELECT DISTINCT M.first_name || ' ' || M.last_name AS full_name, M.phone AS contact_number FROM Member M JOIN Expense E ON M.member_id = E.link_to_member WHERE E.cost > (SELECT AVG(cost) FROM Expense)",
        "difficulty": "challenging",
        "answer": "SELECT DISTINCT M.first_name || ' ' || M.last_name AS full_name, M.phone FROM Expense E JOIN Member M ON E.link_to_member = M.member_id WHERE E.cost > (SELECT AVG(cost) FROM Expense)",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 75,
        "db_id": "student_club",
        "question": "Write the full name of the member who spent money for water, veggie tray and supplies and include the cost of it.",
        "evidence": "full name refers to first_name, last name; spent money for refers expense description; expense_description = 'Water, Veggie tray, supplies'",
        "SQL": "SELECT T2.first_name || ' ' || T2.last_name, T1.cost FROM expense AS T1 INNER JOIN member AS T2 ON T1.link_to_member = T2.member_id WHERE T1.expense_description = 'Water, Veggie tray, supplies'",
        "difficulty": "challenging",
        "answer": "SELECT m.first_name, m.last_name, e.cost FROM Expense e JOIN Member m ON e.link_to_member = m.member_id WHERE e.expense_description = 'Water, Veggie tray, supplies'",
        "error reason": "Failed to combine fore- and surname to output a full name.",
        "error type": [
            1
        ]
    },
    {
        "question_id": 76,
        "db_id": "debit_card_specializing",
        "question": "What was the rounded difference in consumption between CZK-paying customers and EUR-paying customers in 2012?",
        "evidence": "Year 2012 can be presented as Between 201201 And 201212, which means between January and December in 2012; Difference in Consumption = CZK customers consumption in 2012 - EUR customers consumption in 2012",
        "SQL": "SELECT CAST(ABS(SUM(CASE WHEN customers.Currency = 'CZK' THEN yearmonth.Consumption ELSE 0 END) - SUM(CASE WHEN customers.Currency = 'EUR' THEN yearmonth.Consumption ELSE 0 END)) AS INTEGER) AS ConsumptionDifference FROM yearmonth JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE yearmonth.Date BETWEEN '201201' AND '201212'",
        "difficulty": "challenging",
        "answer": "SELECT ROUND(SUM(CASE WHEN c.Currency = 'CZK' THEN y.Consumption ELSE 0 END) - SUM(CASE WHEN c.Currency = 'EUR' THEN y.Consumption ELSE 0 END)) AS ConsumptionDifference FROM customers c JOIN yearmonth y ON c.CustomerID = y.CustomerID WHERE y.Date LIKE '2012%'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 77,
        "db_id": "debit_card_specializing",
        "question": "Which of the three segments\u2014SME, LAM and KAM\u2014has the biggest and lowest percentage increases in consumption paid in EUR between 2012 and 2013?",
        "evidence": "Increase or Decrease = consumption for 2013 - consumption for 2012; Percentage of Increase = (Increase or Decrease / consumption for 2013) * 100%; Between 2012 And 2013 can be represented by Between 201201 And 201312; First 4 strings of Date represents the year.",
        "SQL": "WITH consumption_2012 AS (     SELECT c.`Segment`, SUM(y.`Consumption`) AS total_consumption_2012     FROM customers c JOIN yearmonth y ON c.`CustomerID` = y.`CustomerID`     WHERE c.`Currency` = 'EUR' AND y.Date LIKE '2012%'     GROUP BY c.`Segment` ), consumption_2013 AS (     SELECT c.`Segment`, SUM(y.`Consumption`) AS total_consumption_2013     FROM customers c  JOIN yearmonth y ON c.`CustomerID` = y.`CustomerID`     WHERE c.`Currency` = 'EUR' AND y.`Date` LIKE '2013%'     GROUP BY c.`Segment` ), percentage_increase AS (     SELECT c2012.`Segment`,             ((c2013.total_consumption_2013 - c2012.total_consumption_2012) / c2012.total_consumption_2012) * 100 AS percentage_increase     FROM consumption_2012 c2012     JOIN consumption_2013 c2013 ON c2012.`Segment` = c2013.`Segment`     WHERE c2012.`Segment` IN ('SME', 'LAM', 'KAM') )  SELECT `Segment` FROM percentage_increase WHERE percentage_increase IN (     SELECT MAX(percentage_increase) FROM percentage_increase     UNION ALL     SELECT MIN(percentage_increase) FROM percentage_increase ) ORDER BY percentage_increase DESC",
        "difficulty": "challenging",
        "answer": "WITH ConsumptionData AS (     SELECT          c.`Segment`,          SUM(CASE WHEN y.`Date` LIKE '2012%' THEN y.`Consumption` ELSE 0 END) AS Consumption2012,         SUM(CASE WHEN y.`Date` LIKE '2013%' THEN y.`Consumption` ELSE 0 END) AS Consumption2013     FROM          yearmonth y     JOIN          customers c ON y.`CustomerID` = c.`CustomerID`     WHERE          c.`Currency` = 'EUR'     GROUP BY          c.`Segment` ) SELECT      `Segment`,      (Consumption2013 - Consumption2012) / NULLIF(Consumption2012, 0) * 100 AS PercentageIncrease FROM      ConsumptionData ORDER BY      PercentageIncrease DESC",
        "error reason": "Overselected SUM(CASE WHEN y.`Date` LIKE '2012%' THEN y.`Consumption` ELSE 0 END) AS Consumption2012 for sorting purposes, and failed to fetch only the target values.",
        "error type": [
            5
        ]
    },
    {
        "question_id": 78,
        "db_id": "debit_card_specializing",
        "question": "For the customer who paid 634.8 in 2012/8/25, what was the consumption decrease rate from Year 2012 to 2013?",
        "evidence": "'2012/8/24' can be represented by '2012-08-24'; Consumption decrease rate = (consumption_2012 - consumption_2013) / consumption_2012",
        "SQL": "SELECT CAST(SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) - SUM(IIF(SUBSTRING(Date, 1, 4) = '2013', Consumption, 0)) AS FLOAT) / SUM(IIF(SUBSTRING(Date, 1, 4) = '2012', Consumption, 0)) FROM yearmonth WHERE CustomerID = ( SELECT T1.CustomerID FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-25' AND T1.Price = 634.8 )",
        "difficulty": "challenging",
        "answer": "WITH cte AS (SELECT CustomerID FROM transactions_1k WHERE Price = 634.8 AND Date = '2012-08-25'), consumption_2012 AS (SELECT `Consumption` FROM yearmonth WHERE CustomerID IN (SELECT CustomerID FROM cte) AND Date = '201212'), consumption_2013 AS (SELECT `Consumption` FROM yearmonth WHERE CustomerID IN (SELECT CustomerID FROM cte) AND Date = '201313') SELECT (c2.`Consumption` - c1.`Consumption`) / c1.`Consumption` * 100 AS decrease_rate  FROM (SELECT * FROM consumption_2012) c1, (SELECT * FROM consumption_2013) c2",
        "error reason": "Uses '201313', which does not exist. This results in no data being fetched for 2013, making the entire calculation invalid. Hallucianation in fact.",
      "error type": [
        2,
        7
      ]
    },
    {
        "question_id": 79,
        "db_id": "california_schools",
        "question": "Please list the phone numbers of the direct charter-funded schools that are opened after 2000/1/1.",
        "evidence": "Direct charter-funded schools refers to `Charter` = 1 and FundingType = 'Directly funded' in the schools",
        "SQL": "SELECT Phone FROM schools WHERE Charter = 1 AND FundingType = 'Directly funded' AND OpenDate > '2000-01-01'",
        "difficulty": "moderate",
        "answer": "SELECT Phone FROM schools WHERE `Charter` = 1 AND `FundingType` = 'Directly funded' AND `OpenDate` > '2000-01-01'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 80,
        "db_id": "california_schools",
        "question": "Among the schools with an SAT excellence rate of over 0.3, what is the highest eligible free rate for students aged 5-17?",
        "evidence": "Excellence rate = NumGE1500 / NumTstTakr; Eligible free rates for students aged 5-17 = `Free Meal Count (Ages 5-17)` / `Enrollment (Ages 5-17)`",
        "SQL": "SELECT MAX(`Percent (%) Eligible Free (Ages 5-17)`) FROM frpm JOIN satscores ON frpm.`CDSCode` = satscores.`cds` WHERE satscores.`NumTstTakr` > 0 AND (CAST(satscores.`NumGE1500` AS REAL) / CAST(satscores.`NumTstTakr` AS REAL)) > 0.3",
        "difficulty": "moderate",
        "answer": "SELECT MAX(`Percent (%) Eligible Free (Ages 5-17)`) FROM frpm INNER JOIN satscores ON frpm.`CDSCode` = satscores.`cds` WHERE (satscores.`NumGE1500` * 1.0 / satscores.`NumTstTakr`) > 0.3",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 81,
        "db_id": "california_schools",
        "question": "What is the eligible free or reduced price meal rate for the top 5 schools in grades 1-12 with the highest free or reduced price meal count of the schools with the ownership code 66?",
        "evidence": "grades 1-12 means K-12; Eligible free or reduced price meal rate for K-12 = `FRPM Count (K-12)` / `Enrollment (K-12)`",
        "SQL": "SELECT CAST(T1.`FRPM Count (K-12)` AS REAL) / T1.`Enrollment (K-12)` FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode WHERE T2.SOC = 66 ORDER BY T1.`FRPM Count (K-12)` DESC LIMIT 5",
        "difficulty": "moderate",
        "answer": "SELECT `School Name`, `FRPM Count (K-12)`, `Percent (%) Eligible FRPM (K-12)` FROM schools WHERE `DOC` = '66' ORDER BY `FRPM Count (K-12)` DESC LIMIT 5",
        "error reason": "The schools table does not have a column named School Name; Percent (%) Eligible FRPM (K-12) exists in the frpm table, not in the schools table; using DOC = '66' instead of SOC = 66. However, the question specifies filtering based on the School Ownership Code, which corresponds to the SOC column, not DOC;only references the schools table. To calculate the eligible free or reduced price meal rate (FRPM Count (K-12) divided by Enrollment (K-12)), data from both frpm and schools tables are required.",
        "error type": [
            1,
            2
        ]
    },
    {
        "question_id": 82,
        "db_id": "financial",
        "question": "Among the accounts who have approved loan date in 1997, list out the accounts that have the lowest approved amount and choose weekly issuance statement.",
        "evidence": "'POPLATEK TYDNE' stands for weekly issuance",
        "SQL": "SELECT T2.account_id FROM loan AS T1 INNER JOIN account AS T2 ON T1.account_id = T2.account_id WHERE STRFTIME('%Y', T1.date) = '1997' AND T2.frequency = 'POPLATEK TYDNE' ORDER BY T1.amount LIMIT 1",
        "difficulty": "moderate",
        "answer": "SELECT DISTINCT l.account_id FROM loan l JOIN account a ON l.account_id = a.account_id WHERE strftime('%Y', l.date) = '1997' AND l.amount = (SELECT MIN(amount) FROM loan WHERE strftime('%Y', date) = '1997') AND a.frequency = 'POPLATEK TYDNE'",
        "error reason": "Failed to recognize that 'POPLATEK TYDNE' stands for weekly issuance, which is decribed in the table schema",
        "error type": [
          2
        ]
    },
    {
        "question_id": 83,
        "db_id": "financial",
        "question": "What is the percentage of loan amount that has been fully paid with no issue.",
        "evidence": "Loan paid with no issue means contract finished, no problems; status = 'A' means contract finished, no problems; Percentage of accounts by condition = [(total(amount) & condition) / (total amount)] * 100%",
        "SQL": "SELECT (CAST(SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) AS REAL) * 100) / SUM(amount) FROM loan",
        "difficulty": "moderate",
        "answer": "SELECT (SUM(CASE WHEN status = 'A' THEN amount ELSE 0 END) * 100.0 / SUM(amount)) AS percentage_fully_paid FROM loan",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 84,
        "db_id": "financial",
        "question": "What was the difference in the number of crimes committed in East and North Bohemia in 1996?",
        "evidence": "Difference in no. of committed crimes between 2 regions = Total no. of committed crimes in 1996 in North Bohemia - Total no. of committed crimes in 1996 in East Bohemia. A3 refers to region. Data about no. of committed crimes 1996 appears in A16",
        "SQL": "SELECT ABS((SELECT SUM(`A16`) FROM `district` WHERE `A3` = 'east Bohemia') -(SELECT SUM(`A16`) FROM `district` WHERE `A3` = 'north Bohemia')) AS crime_difference",
        "difficulty": "moderate",
        "answer": "SELECT SUM(CASE WHEN A3 = 'east Bohemia' THEN A16 ELSE 0 END) - SUM(CASE WHEN A3 = 'north Bohemia' THEN A16 ELSE 0 END) AS crime_difference FROM district WHERE A3 IN ('east Bohemia', 'north Bohemia')",
        "error reason": "Failed to use ABS for a absolute value. Semantic misunderstanding.",
        "error type": [
          1,
          4
        ]
    },
    {
        "question_id": 85,
        "db_id": "toxicology",
        "question": "Which molecule does the atom TR001_10 belong to? Please state whether this molecule is carcinogenic or not with 'YES' or 'NO'.",
        "evidence": "TR001_10 is the atom id; label = '+' mean molecules are carcinogenic",
        "SQL": "SELECT T2.molecule_id , IIF(T2.label = '+', 'YES', 'NO') AS flag_carcinogenic FROM atom AS T1 INNER JOIN molecule AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.atom_id = 'TR001_10'",
        "difficulty": "challenging",
        "answer": "SELECT m.`molecule_id`, CASE WHEN m.`label` = '+' THEN 'YES' ELSE 'NO' END AS carcinogenic FROM atom a JOIN molecule m ON a.`molecule_id` = m.`molecule_id` WHERE a.`atom_id` = 'TR001_10'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 86,
        "db_id": "toxicology",
        "question": "What percentage of bonds have the most common combination of atoms' elements?",
        "evidence": "DIVIDE(COUNT(bond_id), COUNT(atom_id where MAX(COUNT(atom_id)) ))",
        "SQL": "WITH total_bonds AS (SELECT COUNT(*) AS total FROM bond), element_combinations AS (SELECT MIN(a1.element, a2.element) AS element1, MAX(a1.element, a2.element) AS element2 FROM connected c JOIN atom a1 ON c.atom_id = a1.atom_id JOIN atom a2 ON c.atom_id2 = a2.atom_id GROUP BY bond_id), most_common_combination AS (SELECT element1, element2, COUNT(*) AS combination_count FROM element_combinations GROUP BY element1, element2 ORDER BY combination_count DESC LIMIT 1) SELECT (most_common_combination.combination_count * 100.0) / total_bonds.total AS percentage FROM most_common_combination, total_bonds",
        "difficulty": "challenging",
        "answer": "WITH Most_Common_Atoms AS (     SELECT a1.`element`, a2.`element`, COUNT(*) as Count     FROM connected c     JOIN bond b ON c.`bond_id` = b.`bond_id`     JOIN atom a1 ON c.`atom_id` = a1.`atom_id`     JOIN atom a2 ON c.`atom_id2` = a2.`atom_id`     GROUP BY a1.`element`, a2.`element`     ORDER BY Count DESC     LIMIT 1 ), Total_Bonds AS (     SELECT COUNT(*) as Total FROM bond ) SELECT (SELECT Count FROM Most_Common_Atoms) * 100.0 / (SELECT Total FROM Total_Bonds) as Percentage",
        "error reason": "Directly groups by a1.element and a2.element without enforcing an order. This means (C, H) and (H, C) are considered different combinations. If a particular combination appears in both orders across different bonds, the COUNT(*) aggregates them separately, inflating the count for the most common combination.",
        "error type": [
            6
        ]
    },
    {
        "question_id": 87,
        "db_id": "toxicology",
        "question": "Which non-carcinogenic molecules consisted more than 5 atoms?",
        "evidence": "label = '-' means molecules are non-carcinogenic; molecules consisted more than 5 atoms refers to COUNT(molecule_id) > 5",
        "SQL": "SELECT T.molecule_id FROM ( SELECT T1.molecule_id, COUNT(T2.atom_id) FROM molecule AS T1 INNER JOIN atom AS T2 ON T1.molecule_id = T2.molecule_id WHERE T1.label = '-' GROUP BY T1.molecule_id HAVING COUNT(T2.atom_id) > 5 ) t",
        "difficulty": "moderate",
        "answer": "SELECT a.`molecule_id` FROM atom a JOIN molecule m ON a.`molecule_id` = m.`molecule_id` WHERE m.`label` = '-' GROUP BY a.`molecule_id` HAVING COUNT(a.`atom_id`) > 5",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 88,
        "db_id": "card_games",
        "question": "List all the card id and artist with unknown power which are legal for commander play format.",
        "evidence": "unknown power refers to power = '*' or POWER IS NULL; commander play format refers to format = 'commander'; legal for commander play format refers to format = 'commander' where status = 'Legal'",
        "SQL": "SELECT T1.id, T1.artist FROM cards AS T1 INNER JOIN legalities AS T2 ON T1.uuid = T2.uuid WHERE T2.status = 'Legal' AND T2.format = 'commander' AND (T1.power IS NULL OR T1.power = '*')",
        "difficulty": "moderate",
        "answer": "SELECT c.id, c.artist FROM cards c JOIN legalities l ON c.uuid = l.uuid WHERE c.power = '*' AND l.format = 'commander' AND l.status = 'Legal'",
        "error reason": "Does not include c.power IS NULL, thereby excluding cards where the power is unknown but set to NULL. Missing NULL handing strategy.",
        "error type": [
            6
        ]
    },
    {
        "question_id": 89,
        "db_id": "card_games",
        "question": "Among the Artifact cards, which are black color and comes with foreign languague translation?",
        "evidence": "Artifact card refers to Type = 'Artifact'; black color refers to colors = 'B'; foreign language refers to language in foreign_data",
        "SQL": "SELECT DISTINCT c.name FROM cards c INNER JOIN foreign_data f ON c.uuid = f.uuid WHERE c.type LIKE '%Artifact%' AND c.colors LIKE '%B%'",
        "difficulty": "moderate",
        "answer": "SELECT c.*, f.translation FROM cards c JOIN foreign_data f ON c.id = f.multiverseid WHERE c.type LIKE '%Artifact%' AND c.colors LIKE '%B%' AND f.language IS NOT NULL",
        "error reason": "The cards table uses uuid as its unique identifier, not id. Moreover, foreign_data links to cards via uuid, not multiverseid;The foreign_data table does not have a translation column. Memory recall failure.",
        "error type": [
          2,
          5
        ]
    },
    {
        "question_id": 90,
        "db_id": "card_games",
        "question": "What percentage of legendary frame effect cards have a maximum starting maximun hand\nsize of +3?",
        "evidence": "maximun hand size of +3 refer to hand = +3; legendary frame effect cards refer to frameEffects = 'legendary'; percentage refer to DIVIDE(COUNT(hand = '+3'), COUNT(id)) from cards where frameEffects = 'legendary'",
        "SQL": "SELECT SUM(CASE WHEN hAND = '+3' THEN 1.0 ELSE 0 END) / COUNT(id) * 100 FROM cards WHERE frameEffects = 'legendary'",
        "difficulty": "moderate",
        "answer": "SELECT (CAST(COUNT(*) AS REAL) / (SELECT COUNT(*) FROM cards WHERE frameEffects LIKE '%legendary%')) * 100 AS percentage FROM cards WHERE frameEffects LIKE '%legendary%' AND hand = '+3'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 91,
        "db_id": "codebase_community",
        "question": "What is the display name of the user who last edited the post \"Examples for teaching: Correlation does not mean causation\"?",
        "evidence": "\"Examples for teaching: Correlation does not mean causation\" is the Title of post; user who last edited refers to LastEditorUserId",
        "SQL": "SELECT T2.DisplayName FROM posts AS T1 INNER JOIN users AS T2 ON T1.LastEditorUserId = T2.Id WHERE T1.Title = 'Examples for teaching: Correlation does not mean causation'",
        "difficulty": "moderate",
        "answer": "SELECT u.DisplayName FROM posts p JOIN users u ON p.LastEditorUserId = u.Id WHERE p.Title = 'Examples for teaching: Correlation does not mean causation'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 92,
        "db_id": "codebase_community",
        "question": "Calculate the average view count of posts tagged as 'humor' and write the title and the comments of the posts alongside their scores if applicable.",
        "evidence": "\"humor\" is the Tags; comment of the post refers to Text; average view count = AVG(ViewCount)",
        "SQL": "SELECT (SELECT AVG(ViewCount) FROM posts WHERE Tags LIKE '%<humor>%') AS AverageViewCount, p.Title, c.Text AS Comment, c.Score AS CommentScore FROM posts p LEFT JOIN comments c ON p.Id = c.PostId WHERE p.Tags LIKE '%<humor>%'",
        "difficulty": "challenging",
        "answer": "SELECT AVG(p.ViewCount) AS AverageViewCount, p.Title, c.Text AS Comment, c.Score FROM posts p JOIN comments c ON p.Id = c.PostId JOIN tags t ON p.Tags LIKE '%' || t.TagName || '%' WHERE t.TagName = 'humor' GROUP BY p.Id, p.Title, c.Text, c.Score",
        "error reason": "The posts table already contains the Tags field formatted as <tag1><tag2>. Joining with the tags table based on a LIKE condition (p.Tags LIKE '%' || t.TagName || '%') is unnecessary and inefficient. By using an inner JOIN with the comments table, posts that have no comments are excluded from the results. This contradicts the requirement to include comments 'if applicable'.The query uses AVG(p.ViewCount) alongside a GROUP BY that includes p.Id, p.Title, c.Text, and c.Score. This means the average is calculated over each group defined by these fields, which likely results in the same ViewCount being averaged repeatedly for each comment of a post. Consequently, the AverageViewCount does not represent the true average across all relevant posts but rather an average within each grouped subset, leading to misleading results.",
        "error type": [
            1,
            5
        ]
    },
    {
        "question_id": 93,
        "db_id": "codebase_community",
        "question": "What is the average of the up votes and the average user age for users creating more than 10 posts?",
        "evidence": "creating more than 10 post refers to Count (UserId) > 10; up votes average = Divide (Sum(UpVotes), Count (UserId)); average age = Divide (Sum(Age), Count(UserId))",
        "SQL": "SELECT AVG(T1.UpVotes), AVG(T1.Age) FROM users AS T1 INNER JOIN ( SELECT OwnerUserId, COUNT(*) AS post_count FROM posts GROUP BY OwnerUserId HAVING post_count > 10) AS T2 ON T1.Id = T2.OwnerUserId",
        "difficulty": "moderate",
        "answer": "SELECT AVG(u.UpVotes) AS AverageUpVotes, AVG(u.Age) AS AverageUserAge FROM users AS u WHERE u.Id IN (SELECT OwnerUserId FROM posts GROUP BY OwnerUserId HAVING COUNT(Id) > 10)",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 94,
        "db_id": "superhero",
        "question": "Among the superheroes with the super power of \"Super Strength\", how many of them have a height of over 200cm?",
        "evidence": "super power of \"Super Strength\" refers to power_name = 'Super Strength'; a height of over 200cm refers to height_cm > 200",
        "SQL": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_power AS T2 ON T1.id = T2.hero_id INNER JOIN superpower AS T3 ON T2.power_id = T3.id WHERE T3.power_name = 'Super Strength' AND T1.height_cm > 200",
        "difficulty": "moderate",
        "answer": "SELECT COUNT(DISTINCT sh.id) FROM superhero sh JOIN hero_power hp ON sh.id = hp.hero_id JOIN superpower sp ON hp.power_id = sp.id WHERE sp.power_name = 'Super Strength' AND sh.height_cm > 200",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 95,
        "db_id": "superhero",
        "question": "How many female superheroes have a strength value of 100?",
        "evidence": "female refers to gender = 'Female'; strength value of 100 refers to attribute_name = 'Strength' AND attribute_value = 100",
        "SQL": "SELECT COUNT(T1.id) FROM superhero AS T1 INNER JOIN hero_attribute AS T2 ON T1.id = T2.hero_id INNER JOIN attribute AS T3 ON T2.attribute_id = T3.id INNER JOIN gender AS T4 ON T1.gender_id = T4.id WHERE T3.attribute_name = 'Strength' AND T2.attribute_value = 100 AND T4.gender = 'Female'",
        "difficulty": "moderate",
        "answer": "SELECT COUNT(DISTINCT sh.id) FROM superhero sh INNER JOIN gender g ON sh.gender_id = g.id INNER JOIN hero_attribute ha ON sh.id = ha.hero_id INNER JOIN attribute a ON ha.attribute_id = a.id WHERE g.gender = 'Female' AND a.attribute_name = 'Strength' AND ha.attribute_value = 100",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 96,
        "db_id": "superhero",
        "question": "Among the male superheroes, list the full names of superheroes with weight greater than the 79% average weight of all superheroes.",
        "evidence": "Calculation = weight_kg > MULTIPLY(AVG(weight_kg), 0.79)",
        "SQL": "SELECT T1.full_name FROM superhero AS T1 INNER JOIN gender AS T2 ON T1.gender_id = T2.id WHERE T2.gender = 'Male' AND T1.weight_kg * 100 > ( SELECT AVG(weight_kg) FROM superhero ) * 79",
        "difficulty": "moderate",
        "answer": "SELECT `full_name` FROM superhero WHERE `weight_kg` > (SELECT 0.79 * AVG(`weight_kg`) FROM superhero) AND `gender_id` = (SELECT `id` FROM gender WHERE `gender` = 'Male')",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 97,
        "db_id": "formula_1",
        "question": "How many races in the year 2010 are held on grand prixs outside Asia and Europe?",
        "evidence": "",
        "SQL": "SELECT COUNT(T3.raceId) FROM circuits AS T1 INNER JOIN races AS T3 ON T3.circuitId = T1.circuitId WHERE T1.country NOT IN ( 'Bahrain', 'China', 'Singapore', 'Japan', 'Korea', 'Turkey', 'UAE', 'Malaysia', 'Spain', 'Monaco', 'Azerbaijan', 'Austria', 'Belgium', 'France', 'Germany', 'Hungary', 'Italy', 'UK' ) AND T3.year = 2010",
        "difficulty": "moderate",
        "answer": "SELECT COUNT(DISTINCT r.raceId) FROM races r JOIN circuits c ON r.circuitId = c.circuitId WHERE r.year = 2010 AND c.country NOT IN ('Asia', 'Europe')",
        "error reason": "The country field in the circuits table contains country names (e.g., 'Bahrain', 'UK', 'Morocco'), not continent names.",
        "error type": [
            1
        ]
    },
    {
        "question_id": 98,
        "db_id": "formula_1",
        "question": "Among all European Grand Prix races, what is the percentage of the races were hosted in Germany?",
        "evidence": "percentage = divide(COUNT(races where country = Germany and name = 'Europearn Grand Prix'),COUNT(races where name = 'Europearn Grand Prix'))*100",
        "SQL": "SELECT CAST(COUNT(CASE WHEN T1.country = 'Germany' THEN T2.circuitID END) AS REAL) * 100 / COUNT(T2.circuitId) FROM circuits AS T1 INNER JOIN races AS T2 ON T2.circuitID = T1.circuitId WHERE T2.name = 'European Grand Prix'",
        "difficulty": "moderate",
        "answer": "SELECT (COUNT(CASE WHEN c.country = 'Germany' THEN 1 END) * 100.0 / COUNT(*)) AS percentage FROM races AS r JOIN circuits AS c ON r.circuitId = c.circuitId WHERE r.name LIKE '%European Grand Prix%'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 99,
        "db_id": "formula_1",
        "question": "Among the drivers that finished the race in the 2008 Australian Grand Prix, how many of them have participated in Formula_1 races?",
        "evidence": "COUNT(raceID) > 0 reveals that this driver participated in races; drivers who finished the race refers to time has value.",
        "SQL": "SELECT COUNT(*) FROM ( SELECT T1.driverId FROM results AS T1 INNER JOIN races AS T2 on T1.raceId = T2.raceId WHERE T2.name = 'Australian Grand Prix' AND T2.year = 2008 AND T1.time IS NOT NULL GROUP BY T1.driverId HAVING COUNT(T2.raceId) > 0 )",
        "difficulty": "moderate",
        "answer": "SELECT COUNT(DISTINCT r.driverId) FROM results r INNER JOIN races ra ON r.raceId = ra.raceId WHERE ra.name = 'Australian Grand Prix' AND ra.year = 2008 AND r.driverId IN (SELECT driverId FROM drivers)",
        "error reason": "r.driverId IN (SELECT driverId FROM drivers): This condition is unnecessary because the results table already contains driverId values that reference existing drivers; Does not include a condition to check if the driver finished the race. This means it counts all drivers who participated in the 2008 Australian Grand Prix, regardless of whether they finished or not. The absence of r.time IS NOT NULL allows drivers who did not finish (DNF) the race to be included in the count. ",
        "error type": [
          2,  
          5
        ]
    },
    {
        "question_id": 100,
        "db_id": "european_football_2",
        "question": "Which home team had lost the fewest matches in the 2015 to 2016 season?",
        "evidence": "home team lost the matches refers to SUBTRACT(home_team_goal, away_team_goal) < 0; 2015 season refers to season = '2015/2016';",
        "SQL": "WITH LossesPerTeam AS (SELECT home_team_api_id, SUM(CASE WHEN home_team_goal < away_team_goal THEN 1 ELSE 0 END) AS losses FROM Match WHERE season = '2015/2016' GROUP BY home_team_api_id), MinLosses AS (SELECT MIN(losses) AS min_losses FROM LossesPerTeam) SELECT Team.team_long_name FROM LossesPerTeam JOIN Team ON LossesPerTeam.home_team_api_id = Team.team_api_id WHERE LossesPerTeam.losses = (SELECT min_losses FROM MinLosses)",
        "difficulty": "moderate",
        "answer": "SELECT home_team_api_id, COUNT(*) AS lost_matches FROM Match WHERE season = '2015/2016' AND home_team_goal < away_team_goal GROUP BY home_team_api_id ORDER BY lost_matches ASC LIMIT 1",
        "error reason": "The LIMIT 1 clause restricts the result to only one team, even if multiple teams share the same minimum number of losses; returns home_team_api_id instead of the actual team names.",
        "error type": [
            1,
            6
        ]
    },
    {
        "question_id": 101,
        "db_id": "european_football_2",
        "question": "What are the speed in which attacks are put together of the top 4 teams with the highest build Up Play Speed?",
        "evidence": "speed in which attacks are put together refers to buildUpPlaySpeed;highest build up play speed refers to MAX(buildUpPlaySpeed)",
        "SQL": "SELECT ta.`buildUpPlaySpeed` FROM Team t JOIN Team_Attributes ta ON t.`team_api_id` = ta.`team_api_id` ORDER BY ta.`buildUpPlaySpeed` DESC LIMIT 4",
        "difficulty": "moderate",
        "answer": "SELECT buildUpPlaySpeed FROM Team_Attributes ORDER BY buildUpPlaySpeed DESC LIMIT 4",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 102,
        "db_id": "european_football_2",
        "question": "List the top 5 leagues in ascending order of the number of goals made in all seasons combined.",
        "evidence": "number of goals made in all seasons combine = SUM(home_team_goal, away_team_goal);",
        "SQL": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id GROUP BY t1.name ORDER BY SUM(t2.home_team_goal) + SUM(t2.away_team_goal) ASC LIMIT 5",
        "difficulty": "moderate",
        "answer": "SELECT l.name, SUM(m.home_team_goal + m.away_team_goal) AS total_goals  FROM League l  JOIN Match m ON l.id = m.league_id  GROUP BY l.id  ORDER BY total_goals ASC  LIMIT 5",
        "error reason": "Overselected total_goals for sorting purpose.",
        "error type": [
            5
        ]
    },
    {
        "question_id": 103,
        "db_id": "european_football_2",
        "question": "List the top 10 players' names whose heights are above 180 in descending order of average heading accuracy.",
        "evidence": "height > 180; average heading accuracy = DIVIDE(SUM(heading_accuracy), COUNT(player_fifa_api_id));",
        "SQL": "SELECT t1.player_name FROM Player AS t1 INNER JOIN Player_Attributes AS t2 ON t1.player_api_id = t2.player_api_id WHERE t1.height > 180 GROUP BY t1.id ORDER BY CAST(SUM(t2.heading_accuracy) AS REAL) / COUNT(t2.`player_fifa_api_id`) DESC LIMIT 10",
        "difficulty": "moderate",
        "answer": "SELECT p.player_name FROM Player p JOIN Player_Attributes pa ON p.player_api_id = pa.player_api_id WHERE p.height > 180 GROUP BY p.player_api_id ORDER BY AVG(pa.heading_accuracy) DESC LIMIT 10",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 104,
        "db_id": "thrombosis_prediction",
        "question": "What is the percentage of female patient were born after 1930?",
        "evidence": "female refers to Sex = 'F'; patient who were born after 1930 refers to year(Birthday) > '1930'; calculation = DIVIDE(COUNT(ID) where year(Birthday) > '1930' and SEX = 'F'), (COUNT(ID) where SEX = 'F')",
        "SQL": "SELECT CAST(SUM(CASE WHEN STRFTIME('%Y', Birthday) > '1930' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(*) FROM Patient WHERE SEX = 'F'",
        "difficulty": "moderate",
        "answer": "SELECT (COUNT(CASE WHEN Birthday > '1930-01-01' THEN 1 END) * 100.0 / COUNT(*)) AS percentage FROM Patient WHERE SEX = 'F'",
        "error reason": "Failed to consider the people born exactly on 1930-01-01 with  Birthday > '1930-01-01'.",
        "error type": [
            4
        ]
    },
    {
        "question_id": 105,
        "db_id": "thrombosis_prediction",
        "question": "State the ID and age of patient with positive degree of coagulation.",
        "evidence": "age refers to SUBTRACT(year(current_timestamp), year(Birthday)); positive degree of coagulation refers to RVVT = '+' or LAC = '+' or KCT = '+'",
        "SQL": "SELECT Examination.`ID`, (strftime('%Y', 'Now') - strftime('%Y', Patient.Birthday)) - (strftime('%m-%d', 'Now') < strftime('%m-%d',Patient.Birthday)) AS age FROM Examination JOIN Patient ON Examination.`ID` = Patient.`ID` WHERE Examination.`KCT` = '+' OR Examination.`RVVT` = '+' OR Examination.`LAC` = '+'",
        "difficulty": "moderate",
        "answer": "SELECT e.ID, strftime('%Y', 'now') - strftime('%Y', p.Birthday) AS Age FROM Examination e JOIN Patient p ON e.ID = p.ID WHERE e.KCT = '+' OR e.RVVT = '+' OR e.LAC = '+'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 106,
        "db_id": "student_club",
        "question": "How many events of the Student_Club did Sacha Harrison attend in 2019?",
        "evidence": "events attended in 2019 refers to YEAR(event_date) = 2019",
        "SQL": "SELECT COUNT(T1.event_id) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event INNER JOIN member AS T3 ON T2.link_to_member = T3.member_id WHERE T3.first_name = 'Sacha' AND T3.last_name = 'Harrison' AND SUBSTR(T1.event_date, 1, 4) = '2019'",
        "difficulty": "moderate",
        "answer": "SELECT COUNT(`link_to_event`) FROM Attendance WHERE `link_to_member` = (SELECT `member_id` FROM Member WHERE `first_name` = 'Sacha' AND `last_name` = 'Harrison') AND `link_to_event` IN (SELECT `event_id` FROM Event WHERE strftime('%Y', `event_date`) = '2019')",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 107,
        "db_id": "student_club",
        "question": "What is the average attendance of meetings in 2020?",
        "evidence": "meetings in 2020 refers to type = 'Meeting' where YEAR(event_date) = 2020; average = DIVIDE(COUNT(event_id), COUNT(DISTINCT event_name))",
        "SQL": "SELECT CAST(COUNT(T2.link_to_event) AS REAL) / COUNT(DISTINCT T2.link_to_event) FROM event AS T1 INNER JOIN attendance AS T2 ON T1.event_id = T2.link_to_event WHERE SUBSTR(T1.event_date, 1, 4) = '2020' AND T1.type = 'Meeting'",
        "difficulty": "moderate",
        "answer": "SELECT COUNT(*) / COUNT(DISTINCT `link_to_event`) AS average_attendance FROM Attendance WHERE `link_to_event` IN (SELECT `event_id` FROM Event WHERE `event_date` LIKE '2020%') AND `link_to_event` IN (SELECT `event_id` FROM Event WHERE `type` = 'Meeting')",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 108,
        "db_id": "student_club",
        "question": "How much did the Student_Club members spend on food in September Meeting?",
        "evidence": "amount spent refers to spent; spend on food in September Meeting refers to category = 'Food' where event_name = 'September Meeting'",
        "SQL": "SELECT T2.spent FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event WHERE T1.event_name = 'September Meeting' AND T2.category = 'Food' AND SUBSTR(T1.event_date, 6, 2) = '09'",
        "difficulty": "moderate",
        "answer": "SELECT SUM(e.cost) FROM Expense e JOIN Budget b ON e.link_to_budget = b.budget_id JOIN Event ev ON b.link_to_event = ev.event_id WHERE b.category = 'Food' AND ev.event_name = 'September Meeting'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 109,
        "db_id": "student_club",
        "question": "Calculate the difference of the total amount spent in all events by the Student_Club in year 2019 and 2020.",
        "evidence": "SUBTRACT(spent where YEAR(event_date) = 2019, spent where YEAR(event_date) = 2020)",
        "SQL": "SELECT SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2019' THEN T2.spent ELSE 0 END) - SUM(CASE WHEN SUBSTR(T1.event_date, 1, 4) = '2020' THEN T2.spent ELSE 0 END) AS num FROM event AS T1 INNER JOIN budget AS T2 ON T1.event_id = T2.link_to_event",
        "difficulty": "challenging",
        "answer": "SELECT (SELECT SUM(spent) FROM Budget JOIN Event ON Budget.link_to_event = Event.event_id WHERE strftime('%Y', Event.event_date) = '2019') - (SELECT SUM(spent) FROM Budget JOIN Event ON Budget.link_to_event = Event.event_id WHERE strftime('%Y', Event.event_date) = '2020') AS total_difference",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 110,
        "db_id": "debit_card_specializing",
        "question": "What was the average monthly consumption of customers in SME for the year 2013?",
        "evidence": "Average Monthly consumption = AVG(Consumption) / 12; Year 2013 can be presented as Between 201301 And 201312, which means between January and December in 2013",
        "SQL": "SELECT AVG(avg_monthly_consumption) FROM ( SELECT yearmonth.CustomerID, SUM(Consumption)/12 AS avg_monthly_consumption FROM yearmonth JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE Segment = 'SME' AND Date LIKE '2013%' GROUP BY yearmonth.CustomerID ) AS per_customer",
        "difficulty": "challenging",
        "answer": "SELECT AVG(`Consumption`) FROM yearmonth INNER JOIN customers ON yearmonth.CustomerID = customers.CustomerID WHERE `Segment` = 'SME' AND `Date` LIKE '2013%'",
        "error reason": "Directly averages all Consumption records without considering the per-customer distribution. This means that customers with more records (months) have a disproportionate impact on the final average.",
        "error type": [
            4
        ]
    },
    {
        "question_id": 111,
        "db_id": "debit_card_specializing",
        "question": "For all the transactions happened during 8:00-9:00 in 2012/8/26, how many happened in CZE?",
        "evidence": "Gas station in the Czech Republic implies that Country = CZE; '2012/8/26' can be represented by '2012-08-26'",
        "SQL": "SELECT COUNT(T1.TransactionID) FROM transactions_1k AS T1 INNER JOIN gasstations AS T2 ON T1.GasStationID = T2.GasStationID WHERE T1.Date = '2012-08-26' AND T1.Time BETWEEN '08:00:00' AND '09:00:00' AND T2.Country = 'CZE'",
        "difficulty": "moderate",
        "answer": "SELECT COUNT(*) FROM transactions_1k t JOIN gasstations g ON t.GasStationID = g.GasStationID WHERE t.Date = '2012-08-26' AND t.Time BETWEEN '08:00:00' AND '09:00:00' AND g.Country = 'CZE'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 112,
        "db_id": "california_schools",
        "question": "Please list the zip code of all the charter schools in Fresno County Office of Education.",
        "evidence": "Charter schools refers to `Charter School (Y/N)` = 1 in the table fprm",
        "SQL": "SELECT Zip FROM schools WHERE County = 'Fresno' AND District = 'Fresno County Office of Education' AND Charter = 1",
        "difficulty": "simple",
        "answer": "SELECT Zip FROM schools WHERE Charter = 1 AND County = 'Fresno'",
        "error reason": "Missing District = 'Fresno County Office of Education'. Memory recall failure.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 113,
        "db_id": "california_schools",
        "question": "In Los Angeles how many schools have more than 500 free meals but less than 700 free or reduced price meals for K-12?",
        "evidence": "",
        "SQL": "SELECT COUNT(CDSCode) FROM frpm WHERE `County Name` = 'Los Angeles' AND `Free Meal Count (K-12)` > 500 AND `FRPM Count (K-12)` < 700",
        "difficulty": "simple",
        "answer": "SELECT COUNT(*) FROM frpm WHERE `County Name` = 'Los Angeles' AND `Free Meal Count (K-12)` > 500 AND `FRPM Count (K-12)` < 700",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 114,
        "db_id": "california_schools",
        "question": "Which cities have the top 5 lowest enrollment number for students in grades 1 through 12?",
        "evidence": "K-12 refers to students in grades 1 through 12.",
        "SQL": "SELECT T2.City FROM frpm AS T1 INNER JOIN schools AS T2 ON T1.CDSCode = T2.CDSCode GROUP BY T2.City ORDER BY SUM(T1.`Enrollment (K-12)`) ASC LIMIT 5",
        "difficulty": "simple",
        "answer": "SELECT City, enroll12 FROM satscores ORDER BY enroll12 ASC LIMIT 5",
        "error reason": "The satscores table does not have a City column. Memory recall failure.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 115,
        "db_id": "financial",
        "question": "State the district and region for loan ID '4990'.",
        "evidence": "A2, A3 contains the information about district and region respectively.",
        "SQL": "SELECT T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.loan_id = 4990",
        "difficulty": "simple",
        "answer": "SELECT d.`A2`, d.`A3` FROM loan l JOIN account a ON l.`account_id` = a.`account_id` JOIN district d ON a.`district_id` = d.`district_id` WHERE l.`loan_id` = 4990",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 116,
        "db_id": "financial",
        "question": "Provide the account ID, district and region for loan amount greater than USD300,000.",
        "evidence": "A2 contains district names and A3 contains region names.",
        "SQL": "SELECT T1.account_id, T2.A2, T2.A3 FROM account AS T1 INNER JOIN district AS T2 ON T1.district_id = T2.district_id INNER JOIN loan AS T3 ON T1.account_id = T3.account_id WHERE T3.amount > 300000",
        "difficulty": "simple",
        "answer": "SELECT l.account_id, d.A2 AS district, d.A3 AS region FROM loan l JOIN account a ON l.account_id = a.account_id JOIN district d ON a.district_id = d.district_id WHERE l.amount > 300000",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 117,
        "db_id": "financial",
        "question": "Calculate the percentage of account from 'Decin' district for all accounts are opened in 1993.",
        "evidence": "A2 contains the information about district.",
        "SQL": "SELECT CAST(SUM(T1.A2 = 'Decin') AS REAL) * 100 / COUNT(account_id) FROM district AS T1 INNER JOIN account AS T2 ON T1.district_id = T2.district_id WHERE STRFTIME('%Y', T2.date) = '1993'",
        "difficulty": "simple",
        "answer": "WITH total_accounts AS (SELECT COUNT(*) AS total FROM account WHERE strftime('%Y', date) = '1993'), decin_accounts AS (SELECT COUNT(*) AS count FROM account JOIN district ON account.district_id = district.district_id WHERE district.A2 = 'Decin' AND strftime('%Y', account.date) = '1993') SELECT (decin_accounts.count * 100.0 / total_accounts.total) AS percentage FROM total_accounts, decin_accounts",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 118,
        "db_id": "toxicology",
        "question": "Write down the atom IDs of the first and second atoms of triple bond type molecules.",
        "evidence": "first atom refers to atom_id; second atom refers to atom_id2; triple bond refers to bond_type = '#';",
        "SQL": "SELECT T2.atom_id, T2.atom_id2 FROM bond AS T1 INNER JOIN connected AS T2 ON T1.bond_id = T2.bond_id WHERE T1.bond_type = '#'",
        "difficulty": "simple",
        "answer": "SELECT c.`atom_id`, c.`atom_id2` FROM connected c JOIN bond b ON c.`bond_id` = b.`bond_id` WHERE b.`bond_type` = '#'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 119,
        "db_id": "toxicology",
        "question": "Among all chemical compounds identified in the database, what percent of compounds form a triple-bond.",
        "evidence": "triple bond refers to bond_type = '#';",
        "SQL": "SELECT 100.0 * COUNT(DISTINCT molecule_id) / (SELECT COUNT(DISTINCT molecule_id) FROM molecule) AS percentage FROM bond WHERE bond_type = '#'",
        "difficulty": "simple",
        "answer": "SELECT (COUNT(DISTINCT b.molecule_id) * 100.0 / (SELECT COUNT(DISTINCT molecule_id) FROM molecule)) AS percent_triple_bond FROM bond b WHERE b.bond_type = '#'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 120,
        "db_id": "toxicology",
        "question": "in molecules with triple bonds, how many of them are not carcinogenic?",
        "evidence": "triple bond refers to bond_type = '#'; label = '-' means molecules are non-carcinogenic",
        "SQL": "SELECT COUNT(DISTINCT T1.molecule_id) FROM molecule AS T1 INNER JOIN bond AS T2 ON T1.molecule_id = T2.molecule_id WHERE T2.bond_type = '#' AND T1.label = '-'",
        "difficulty": "simple",
        "answer": "SELECT COUNT(DISTINCT b.molecule_id) FROM bond b JOIN molecule m ON b.molecule_id = m.molecule_id WHERE b.bond_type = '#' AND m.label = '-'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 121,
        "db_id": "card_games",
        "question": "Please provide the names of the artists who illustrated the card art in Phyrexian.",
        "evidence": "Phyrexian' is the language; name of artists refers to artist;",
        "SQL": "SELECT T1.artist FROM cards AS T1 INNER JOIN foreign_data AS T2 ON T1.uuid = T2.uuid WHERE T2.language = 'Phyrexian'",
        "difficulty": "simple",
        "answer": "SELECT DISTINCT artist FROM cards WHERE setCode = 'Phyrexian'",
        "error reason": "The setCode column in the cards table represents the set to which a card belongs (e.g., 'ZNR', '10E'). 'Phyrexian' is not a valid setCode but rather a language attribute. Memory recall failure.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 122,
        "db_id": "card_games",
        "question": "How many cards with original type of \"Summon - Angel\" have subtype more than \"Angel\"?",
        "evidence": "subtype other than Angel refers to subtypes is not 'Angel';",
        "SQL": "SELECT COUNT(id) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes != 'Angel'",
        "difficulty": "simple",
        "answer": "SELECT COUNT(*) FROM cards WHERE originalType = 'Summon - Angel' AND subtypes > 'Angel'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 123,
        "db_id": "card_games",
        "question": "List the expansion type of the set \"Huiti\u00e8me \u00e9dition\".",
        "evidence": "the set \"Huiti\u00e8me \u00e9dition\" refers to translation = 'Huiti\u00e8me \u00e9dition'; expansion type refers to type",
        "SQL": "SELECT type FROM sets WHERE code IN ( SELECT setCode FROM set_translations WHERE translation = 'Huiti\u00e8me \u00e9dition' )",
        "difficulty": "challenging",
        "answer": "SELECT type FROM sets WHERE name = 'Huiti\u00e8me \u00e9dition'",
        "error reason": "'Huiti\u00e8me \u00e9dition' is in field translation, not name. Memory recall failure.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 124,
        "db_id": "codebase_community",
        "question": "What is the average number of badges obtained by a user with over 200 views?",
        "evidence": "user with over 200 views refers to Views > 200; average number of badges = Divide (Count(Id), Count(DisplayName))",
        "SQL": "SELECT CAST(COUNT(T1.Id) AS REAL) / COUNT(DISTINCT T2.DisplayName) FROM badges AS T1 INNER JOIN users AS T2 ON T1.UserId = T2.Id WHERE T2.Views > 200",
        "difficulty": "simple",
        "answer": "SELECT AVG(badge_count) FROM (SELECT COUNT(b.Id) AS badge_count FROM badges b INNER JOIN users u ON b.UserId = u.Id INNER JOIN posts p ON u.Id = p.OwnerUserId WHERE p.ViewCount > 200 GROUP BY u.Id)",
        "error reason": "The question asks for users with over 200 total views (users.Views), not users who have at least one post with over 200 individual post views (posts.ViewCount); If a user has multiple posts each with over 200 views, the join with the posts table will create multiple rows for the same badge. This can lead to overcounting badges for such users; joining with the posts table is unnecessary and introduces complexity that leads to errors.",
        "error type": [
            1,
            5
        ]
    },
    {
        "question_id": 125,
        "db_id": "codebase_community",
        "question": "What is the title for the post which got the highest score comment?",
        "evidence": "highest score comment refers to Max(comments.Score)",
        "SQL": "SELECT Title FROM posts WHERE Id = ( SELECT PostId FROM comments ORDER BY Score DESC LIMIT 1 )",
        "difficulty": "simple",
        "answer": "SELECT p.Title FROM posts p JOIN comments c ON p.Id = c.PostId WHERE c.Score = (SELECT MAX(Score) FROM comments)",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 126,
        "db_id": "codebase_community",
        "question": "Give the number of votes for the post about data visualization.",
        "evidence": "About data visualization is the Title that contains 'data visualization';",
        "SQL": "SELECT COUNT(*) FROM votes WHERE PostId IN (SELECT Id FROM posts WHERE Title LIKE '%data visualization%' OR Tags LIKE '%<data-visualization>%')",
        "difficulty": "simple",
        "answer": "SELECT COUNT(*) FROM votes WHERE PostId IN (SELECT Id FROM posts WHERE Body LIKE '%data visualization%')",
        "error reason": "Only searches within the Body of posts. It completely ignores the Title and Tags, which are crucial for accurately identifying posts about data visualizatio; fails to recognize that the data can be LIKE '%<data-visualization>%'. Memory recall failure. ",
        "error type": [
            1,
            2
        ]
    },
    {
        "question_id": 127,
        "db_id": "codebase_community",
        "question": "List out all post ID with score more than 60 and list out all the user ID that created these post.",
        "evidence": "score more than 60 refers to Score > 60",
        "SQL": "SELECT Id, OwnerUserId FROM posts WHERE Score > 60",
        "difficulty": "challenging",
        "answer": "SELECT DISTINCT Id AS PostId, OwnerUserId FROM posts WHERE Score > 60",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 128,
        "db_id": "superhero",
        "question": "What is the publisher's name of Blue Beetle II?",
        "evidence": "Blue Beetle II refers to superhero_name = 'Blue Beetle II'",
        "SQL": "SELECT T2.publisher_name FROM superhero AS T1 INNER JOIN publisher AS T2 ON T1.publisher_id = T2.id WHERE T1.superhero_name = 'Blue Beetle II'",
        "difficulty": "simple",
        "answer": "SELECT p.`publisher_name` FROM superhero s JOIN publisher p ON s.`publisher_id` = p.`id` WHERE s.`superhero_name` = 'Blue Beetle II'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 129,
        "db_id": "superhero",
        "question": "Find the average weight of the heroes who are aliens.",
        "evidence": "average = AVG(weight_kg); aliens refers to race = 'Alien';",
        "SQL": "SELECT CAST(SUM(T1.weight_kg) AS REAL) / COUNT(T1.id) FROM superhero AS T1 INNER JOIN race AS T2 ON T1.race_id = T2.id WHERE T2.race = 'Alien'",
        "difficulty": "simple",
        "answer": "SELECT AVG(weight_kg) FROM superhero WHERE race_id IN (SELECT id FROM race WHERE race = 'Alien')",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 130,
        "db_id": "superhero",
        "question": "List the full names of superheroes with missing weight.",
        "evidence": "missing weight refers to weight_kg = 0 OR weight_kg = NULL;",
        "SQL": "SELECT DISTINCT full_name FROM superhero WHERE full_name IS NOT NULL AND (weight_kg IS NULL OR weight_kg = 0)",
        "difficulty": "simple",
        "answer": "SELECT full_name FROM superhero WHERE weight_kg IS NULL OR weight_kg = 0",
        "error reason": "Includes superhero entries where full_name is NULL. This results in rows with NULL values appearing in the result set, which is typically undesirable when listing names; No DISTINCT Keyword. Semantic misunderstanding.",
        "error type": [
            5,
            6
        ]
    },
    {
        "question_id": 131,
        "db_id": "formula_1",
        "question": "For the driver who had the Q2 time as 0:01:40 in the qualifying race No. 355, what is his nationality?",
        "evidence": "race number refers to raceId;",
        "SQL": "SELECT DISTINCT T2.nationality FROM qualifying AS T1 INNER JOIN drivers AS T2 ON T2.driverId = T1.driverId WHERE T1.raceId = 355 AND T1.q2 LIKE '1:40%'",
        "difficulty": "simple",
        "answer": "SELECT nationality FROM drivers WHERE driverId = (SELECT driverId FROM qualifying WHERE raceId = 355 AND q2 = '0:01:40')",
        "error reason": "Mistaken 'Q2 time as 0:01:40' for q2 = '0:01:40' instead of T1.q2 LIKE '1:40%'. Semantic misunderstanding.",
        "error type": [
            1
        ]
    },
    {
        "question_id": 132,
        "db_id": "formula_1",
        "question": "For the race happened in 2015/11/29, how many drivers finished the game?",
        "evidence": "",
        "SQL": "SELECT COUNT(T2.driverId) FROM races AS T1 INNER JOIN results AS T2 ON T2.raceId = T1.raceId WHERE T1.date = '2015-11-29' AND T2.time IS NOT NULL",
        "difficulty": "simple",
        "answer": "SELECT COUNT(DISTINCT driverId) FROM results WHERE raceId = (SELECT raceId FROM races WHERE date = '2015-11-29') AND position IS NOT NULL",
        "error reason": "If the subquery (SELECT raceId FROM races WHERE date = '2015-11-29') returns multiple raceIds (which can happen if there are multiple races on the same date), the = operator will cause an error or unintended behavior; In some race results, drivers who did not finish (DNF) the race might still have a position assigned if they were classified (e.g., completed over 90% of the race distance), so use position IS NOT NULL is not safe; Missed DISTINCT.",
        "error type": [
            5,
            6
        ]
    },
    {
        "question_id": 133,
        "db_id": "formula_1",
        "question": "How old is the youngest Japanese driver? What is his name?",
        "evidence": "youngest Japanese driver refers to max(dob); Japanese refers to nationality = 'Japanese'; age = 2022-year(dob)+1\n",
        "SQL": "SELECT (strftime('%Y', 'Now') - strftime('%Y', dob)) - (strftime('%m-%d', 'Now') < strftime('%m-%d',dob)) AS age, forename, surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob DESC LIMIT 1",
        "difficulty": "simple",
        "answer": "SELECT forename, surname FROM drivers WHERE nationality = 'Japanese' ORDER BY dob ASC LIMIT 1",
        "error reason": "Forgot to output the age of the driver. Memory recall failure.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 134,
        "db_id": "european_football_2",
        "question": "What is the average height of players born between 1990 and 1995?",
        "evidence": "average height = DIVIDE(SUM(height), COUNT(id)); players born between 1990 and 1995 refers to birthday > = '1990-01-01 00:00:00' AND birthday < '1996-01-01 00:00:00';",
        "SQL": "SELECT SUM(height) / COUNT(id) FROM Player WHERE SUBSTR(birthday, 1, 4) BETWEEN '1990' AND '1995'",
        "difficulty": "simple",
        "answer": "SELECT AVG(height) FROM Player WHERE birthday BETWEEN '1990-01-01' AND '1995-12-31'",
        "error reason": "The birthday field includes a time component (e.g., '1995-12-31 23:59:59'). The BETWEEN '1990-01-01' AND '1995-12-31' condition may exclude players born on '1995-12-31' after '00:00:00' because '1995-12-31 23:59:59' is lexicographically greater than '1995-12-31'.",
        "error type": [
            4
        ]
    },
    {
        "question_id": 135,
        "db_id": "european_football_2",
        "question": "List the football players with a birthyear of 1970 and a birthmonth of October.",
        "evidence": "players with a birthyear of 1970 and a birthmonth of October refers to substr(birthday,1,4) AS year, substr(birthday,6,2) AS month WHERE year = '1970' AND month = '10';",
        "SQL": "SELECT player_name FROM Player WHERE SUBSTR(birthday, 1, 7) = '1970-10'",
        "difficulty": "simple",
        "answer": "SELECT player_name FROM Player WHERE strftime('%Y', birthday) = '1970' AND strftime('%m', birthday) = '10'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 136,
        "db_id": "european_football_2",
        "question": "Which league had the most matches in the 2008/2009 season?",
        "evidence": "league that had the most matches in the 2008/2009 season refers to MAX(league_id WHERE season = '2008/2009');",
        "SQL": "SELECT t1.name FROM League AS t1 INNER JOIN Match AS t2 ON t1.id = t2.league_id WHERE t2.season = '2008/2009' GROUP BY t1.name ORDER BY COUNT(t2.id) DESC LIMIT 1",
        "difficulty": "simple",
        "answer": "SELECT league_id, COUNT(*) as match_count FROM Match WHERE season = '2008/2009' GROUP BY league_id ORDER BY match_count DESC LIMIT 1",
        "error reason": "League name is required in this situation instead of league_id. Semantic misunderstanding. ",
        "error type": [
            1
        ]
    },
    {
        "question_id": 137,
        "db_id": "thrombosis_prediction",
        "question": "Among all outpatients, list out those have low hemoglobin level. State the different IDs and their sex.",
        "evidence": "outpatients refers to Admission = '-'; low hemoglobin level refers to HBG < 10;",
        "SQL": "SELECT DISTINCT T1.ID, T1.SEX FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.HGB < 10 AND T1.Admission = '-'",
        "difficulty": "simple",
        "answer": "SELECT DISTINCT p.ID, p.SEX FROM Patient p JOIN Laboratory l ON p.ID = l.ID WHERE p.Admission = '-' AND l.HGB < 10",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 138,
        "db_id": "thrombosis_prediction",
        "question": "For the male patients that have a normal prothrombin time, what is their average prothrombin time?",
        "evidence": "male refers to Sex = 'M'; normal prothrombin time refer to PT < 14; average prothrombin time = AVG(PT);",
        "SQL": "SELECT AVG(T2.PT) FROM Patient AS T1 INNER JOIN Laboratory AS T2 ON T1.ID = T2.ID WHERE T2.PT < 14 AND T1.SEX = 'M'",
        "difficulty": "simple",
        "answer": "SELECT AVG(LAB.`PT`) FROM Patient AS PAT JOIN Laboratory AS LAB ON PAT.`ID` = LAB.`ID` WHERE PAT.`SEX` = 'M' AND LAB.`PT` < 14",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 139,
        "db_id": "student_club",
        "question": "Provide the total number of the budget amount for \"September Speaker\" event.",
        "evidence": "'September Speaker' is an event name; total number of budget amount refers to SUM(amount)",
        "SQL": "SELECT SUM(T1.amount) FROM budget AS T1 INNER JOIN event AS T2 ON T1.link_to_event = T2.event_id WHERE T2.event_name = 'September Speaker'",
        "difficulty": "simple",
        "answer": "SELECT SUM(amount) FROM Budget WHERE link_to_event = (SELECT event_id FROM Event WHERE event_name = 'September Speaker')",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 140,
        "db_id": "student_club",
        "question": "List the expenses that spend more than fifty dollars on average.",
        "evidence": "expense refers to expense_description; spend more than fifty dollars on average refers to DIVIDE( SUM(cost), COUNT(expense_id) ) > 50",
        "SQL": "SELECT expense_description FROM expense GROUP BY expense_description HAVING AVG(cost) > 50",
        "difficulty": "simple",
        "answer": "SELECT * FROM Expense WHERE cost > 50",
        "error reason": "Failed to consider the requirement involving cost and expense. Memory recall failure.",
        "error type": [
            2
        ]
    },
    {
        "question_id": 141,
        "db_id": "student_club",
        "question": "Calculate the percentage of zip codes that are PO boxes.",
        "evidence": "DIVIDE(SUM(type = 'PO Box'), COUNT(zip_code)) * 100",
        "SQL": "SELECT CAST(SUM(CASE WHEN type = 'PO Box' THEN 1 ELSE 0 END) AS REAL) * 100 / COUNT(zip_code) FROM zip_code",
        "difficulty": "simple",
        "answer": "SELECT (COUNT(*) * 100.0 / (SELECT COUNT(*) FROM Zip_Code)) AS percentage_of_po_boxes FROM Zip_Code WHERE type = 'PO Box'",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 142,
        "db_id": "debit_card_specializing",
        "question": "What is the ratio of costumers who pay in EUR against customers who pay in CZK?",
        "evidence": "ratio of costumers who pay in EUR against customers who pay in CZK = count(Currency = 'EUR') / count(Currency = 'CZK').",
        "SQL": "SELECT CAST(SUM(IIF(Currency = 'EUR', 1, 0)) AS FLOAT) / SUM(IIF(Currency = 'CZK', 1, 0)) FROM customers",
        "difficulty": "simple",
        "answer": "SELECT (SELECT COUNT(DISTINCT CustomerID) FROM customers WHERE Currency = 'EUR') * 1.0 / (SELECT COUNT(DISTINCT CustomerID) FROM customers WHERE Currency = 'CZK') AS Ratio",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 143,
        "db_id": "debit_card_specializing",
        "question": "Which segment had the least consumption?",
        "evidence": "",
        "SQL": "SELECT T1.Segment FROM customers AS T1 INNER JOIN yearmonth AS T2 ON T1.CustomerID = T2.CustomerID GROUP BY T1.Segment ORDER BY SUM(T2.Consumption) ASC LIMIT 1",
        "difficulty": "simple",
        "answer": "SELECT `Segment`, SUM(`Consumption`) AS total_consumption FROM customers JOIN yearmonth ON customers.`CustomerID` = yearmonth.`CustomerID` GROUP BY `Segment` ORDER BY total_consumption ASC LIMIT 1",
        "error reason": "Overselected SUM(`Consumption`) for sorting purposes.",
        "error type": [
            5
        ]
    },
    {
        "question_id": 144,
        "db_id": "debit_card_specializing",
        "question": "How many more \"discount\" gas stations does the Czech Republic have compared to Slovakia?",
        "evidence": "Computation of more discount = Total no. of discount gas stations in Czech Republic - Total no. of discount gas stations in Slovakia",
        "SQL": "SELECT SUM(IIF(Country = 'CZE', 1, 0)) - SUM(IIF(Country = 'SVK', 1, 0)) FROM gasstations WHERE Segment = 'Discount'",
        "difficulty": "simple",
        "answer": "SELECT (SELECT COUNT(*) FROM gasstations WHERE Country = 'CZE' AND Segment = 'Discount') - (SELECT COUNT(*) FROM gasstations WHERE Country = 'SVK' AND Segment = 'Discount') AS Difference",
        "error reason": "None",
        "error type": []
    },
    {
        "question_id": 145,
        "db_id": "toxicology",
        "question": "Please list top three elements of the toxicology of the molecule TR000 in alphabetical order.",
        "evidence": "TR000 is the molecule id; element = 'cl' means Chlorine; element = 'c' means Carbon; element = 'h' means Hydrogen; element = 'o' means Oxygen, element = 's' means Sulfur; element = 'n' means Nitrogen, element = 'p' means Phosphorus, element = 'na' means Sodium, element = 'br' means Bromine, element = 'f' means Fluorine; element = 'i' means Iodine; element = 'sn' means Tin; element = 'pb' means Lead; element = 'te' means Tellurium; element = 'ca' means Calcium",
        "SQL": "SELECT DISTINCT T.element FROM atom AS T WHERE T.molecule_id = 'TR000' ORDER BY T.element LIMIT 3",
        "difficulty": "challenging",
        "answer": "SELECT DISTINCT element FROM atom WHERE molecule_id = 'TR000' ORDER BY element ASC LIMIT 3",
        "error reason": "None",
        "error type": []
    }
]